<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KinBound</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            overflow: hidden;
        #activeEffects {
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.2), rgba(76, 175, 80, 0.1));
            border: 1px solid rgba(76, 175, 80, 0.3);
            backdrop-filter: blur(10px);
        }
        
        #biomeInfo {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, rgba(26,26,26,0.95), rgba(13,13,13,0.95));
            border: 1px solid #333;
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            min-width: 250px;
        }
        
        #biomeName {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 12px;
            color: #e0e0e0;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .biomeProgressBar {
            background: #1a1a1a;
            height: 8px;
            border-radius: 4px;
            overflow: hidden;
            margin: 8px 0;
        }
        
        .biomeProgressFill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #45a049);
            transition: width 0.5s ease;
        }
        
        .biomeStats {
            display: flex;
            justify-content: space-between;
            margin-top: 12px;
            font-size: 14px;
        }
        
        .biomeStat {
            text-align: center;
        }
        
        .biomeStatNumber {
            font-size: 20px;
            font-weight: bold;
            color: #4CAF50;
        }
        
        .biomeStatLabel {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        #activityLog {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, rgba(26,26,26,0.95), rgba(13,13,13,0.95));
            border: 1px solid #333;
            border-radius: 15px;
            padding: 15px;
            max-width: 300px;
            max-height: 220px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
        }
        .statQualityBar {
            width: 100%;
            height: 20px;
            background: #1a1a1a;
            border-radius: 10px;
            margin: 10px 0;
            position: relative;
            overflow: hidden;
        }
        
        .statQualityFill {
            height: 100%;
            border-radius: 10px;
            transition: width 0.5s ease-out;
            position: relative;
        }
        
        .statQualityFill::after {
            content: attr(data-percent);
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 12px;
            font-weight: 600;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        
        .quality-excellent {
            background: linear-gradient(90deg, #4CAF50, #45a049);
        }
        
        .quality-good {
            background: linear-gradient(90deg, #ff9800, #f57c00);
        }
        
        .quality-poor {
            background: linear-gradient(90deg, #f44336, #d32f2f);
        }
        
        .quality-terrible {
            background: linear-gradient(90deg, #666, #444);
        }
        
        /* Quick catch buttons */
        .quickCatchBar {
            display: flex;
            gap: 8px;
            margin-top: 15px;
            justify-content: center;
        }
        
        .quickCatchBtn {
            padding: 8px 16px;
            background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
            border: 1px solid #444;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .quickCatchBtn:hover {
            background: linear-gradient(135deg, #333, #222);
            border-color: #666;
            transform: translateY(-1px);
        }
        
        .quickCatchBtn.recommended {
            border-color: #4CAF50;
            color: #4CAF50;
        }
        
        /* Fade transitions */
        .fade-enter {
            opacity: 0;
            transform: translateY(10px);
        }
        
        .fade-enter-active {
            opacity: 1;
            transform: translateY(0);
            transition: all 0.3s ease-out;
        }
        
        .fade-exit {
            opacity: 1;
            transform: translateY(0);
        }
        
        .fade-exit-active {
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s ease-in;
        }
        
        #gameContainer {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        #header {
            background: linear-gradient(to bottom, #1a1a1a, #0d0d0d);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #333;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            z-index: 50;
        }
        
        #title {
            font-size: 24px;
            font-weight: bold;
            background: linear-gradient(45deg, #4CAF50, #2196F3);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        #resources {
            display: flex;
            gap: 20px;
            font-size: 14px;
            align-items: center;
        }
        
        .resource {
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(255,255,255,0.05);
            padding: 6px 12px;
            border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .orbsContainer {
            display: flex;
            gap: 15px;
            background: rgba(255,255,255,0.05);
            padding: 6px 15px;
            border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .orbType {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 14px;
        }
        
        .orbIcon {
            font-size: 16px;
        }
        
        #mainArea {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            background: radial-gradient(circle at center, #0d0d0d, #000);
        }
        
        #biomeSelection {
            display: grid;
            grid-template-columns: repeat(2, 320px);
            gap: 25px;
            padding: 20px;
            animation: fadeIn 0.5s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .biomeCard {
            background: linear-gradient(135deg, #1a1a1a, #0d0d0d);
            border: 1px solid #333;
            border-radius: 15px;
            padding: 25px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        .biomeCard::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at center, transparent, rgba(0,0,0,0.4));
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .biomeCard:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border-color: #555;
        }
        
        .biomeCard:hover::before {
            opacity: 1;
        }
        
        .biomeCard.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .biomeCard.disabled:hover {
            transform: none;
            box-shadow: none;
        }
        
        .biomeIcon {
            font-size: 56px;
            margin-bottom: 15px;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
        }
        
        .biomeName {
            font-size: 22px;
            font-weight: 600;
            margin-bottom: 8px;
            letter-spacing: 0.5px;
        }
        
        .biomeDesc {
            font-size: 14px;
            color: #888;
            margin-bottom: 10px;
        }
        
        .biomeTimer {
            font-size: 14px;
            color: #ff6666;
            font-weight: 500;
        }
        
        #explorationArea {
            display: none;
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
            animation: fadeIn 0.5s ease-out;
        }
        
        #biomeBackground {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 1;
            transition: background 0.5s;
        }
        
        .biomeElement {
            position: absolute;
            pointer-events: none;
            opacity: 0.8;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-20px); }
        }
        
        @keyframes sway {
            0%, 100% { transform: rotate(-5deg); }
            50% { transform: rotate(5deg); }
        }
        
        @keyframes flicker {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 0.4; }
        }
        
        @keyframes drift {
            0% { transform: translateX(-100px) translateY(0); }
            100% { transform: translateX(calc(100vw + 100px)) translateY(-50px); }
        }
        
        @keyframes bubble {
            0% { transform: translateY(100vh) scale(0); }
            50% { transform: translateY(50vh) scale(1); }
            100% { transform: translateY(-100px) scale(0.5); }
        }
        
        /* Fire biome animations */
        .lavaGlow {
            animation: flicker 2s ease-in-out infinite;
        }
        
        .emberFloat {
            animation: float 4s ease-in-out infinite;
        }
        
        /* Water biome animations */
        .bubbleRise {
            animation: bubble 10s linear infinite;
        }
        
        .coralSway {
            animation: sway 3s ease-in-out infinite;
            transform-origin: bottom center;
        }
        
        /* Earth biome animations */
        .rockFloat {
            animation: float 6s ease-in-out infinite;
        }
        
        /* Air biome animations */
        .cloudDrift {
            animation: drift 20s linear infinite;
        }
        
        .windSwirl {
            animation: rotate 10s linear infinite;
        }
        
        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        #player {
            position: absolute;
            width: 20px;
            height: 30px;
            z-index: 10;
            transition: left 0.1s linear, top 0.1s linear;
        }
        
        .playerSprite {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        .playerHead {
            width: 10px;
            height: 10px;
            background: #fdbcb4;
            border-radius: 50%;
            position: absolute;
            top: 2px;
            left: 5px;
            border: 1px solid #333;
        }
        
        .playerBody {
            width: 8px;
            height: 10px;
            background: #4CAF50;
            position: absolute;
            top: 12px;
            left: 6px;
            border-radius: 2px 2px 0 0;
        }
        
        .playerArm {
            width: 2px;
            height: 7px;
            background: #fdbcb4;
            position: absolute;
            top: 14px;
        }
        
        .playerArm.left {
            left: 4px;
            transform-origin: top center;
            animation: armSwing 0.5s ease-in-out infinite;
        }
        
        .playerArm.right {
            right: 4px;
            transform-origin: top center;
            animation: armSwing 0.5s ease-in-out infinite reverse;
        }
        
        .playerLeg {
            width: 3px;
            height: 8px;
            background: #2196F3;
            position: absolute;
            top: 22px;
        }
        
        .playerLeg.left {
            left: 5px;
            transform-origin: top center;
            animation: legWalk 0.5s ease-in-out infinite;
        }
        
        .playerLeg.right {
            right: 5px;
            transform-origin: top center;
            animation: legWalk 0.5s ease-in-out infinite reverse;
        }
        
        .player-idle .playerArm,
        .player-idle .playerLeg {
            animation: none !important;
        }
        
        @keyframes armSwing {
            0%, 100% { transform: rotate(-20deg); }
            50% { transform: rotate(20deg); }
        }
        
        @keyframes legWalk {
            0%, 100% { transform: rotate(-15deg); }
            50% { transform: rotate(15deg); }
        }
        
        #encounterModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1e1e1e, #141414);
            border: 1px solid #444;
            border-radius: 20px;
            padding: 30px;
            z-index: 100;
            text-align: center;
            min-width: 450px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.8);
            animation: modalAppear 0.3s ease-out;
        }
        
        @keyframes modalAppear {
            from { 
                opacity: 0;
                transform: translate(-50%, -45%);
            }
            to { 
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }
        
        #encounterModal h2 {
            margin: 0 0 20px 0;
            font-size: 24px;
            font-weight: 600;
        }
        
        .kinSprite {
            width: 120px;
            height: 120px;
            background: radial-gradient(circle, #2a2a2a, #1a1a1a);
            border-radius: 50%;
            margin: 20px auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 60px;
            border: 3px solid #333;
            position: relative;
        }
        
        .kinSprite.radiant {
            border-color: gold;
            background: radial-gradient(circle, #3a3a20, #2a2a10);
            box-shadow: 0 0 30px gold, 0 0 60px gold;
            animation: glow 2s ease-in-out infinite;
        }
        
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 30px gold, 0 0 60px gold; }
            50% { box-shadow: 0 0 40px gold, 0 0 80px gold; }
        }
        
        .kinInfo {
            margin: 15px 0;
            font-size: 16px;
            line-height: 1.6;
        }
        
        .kinInfo > div {
            margin: 8px 0;
        }
        
        .rarity-common { color: #e0e0e0; }
        .rarity-uncommon { color: #4CAF50; }
        .rarity-rare { color: #2196F3; }
        .rarity-epic { color: #9C27B0; }
        
        #orbSelection {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin: 25px 0 10px 0;
            flex-wrap: wrap;
        }
        
        .orbButton {
            background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
            border: 1px solid #444;
            color: #e0e0e0;
            padding: 12px 20px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            font-weight: 500;
            position: relative;
            overflow: hidden;
        }
        
        .orbButton::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255,255,255,0.1);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.3s, height 0.3s;
        }
        
        .orbButton:hover:not(:disabled) {
            background: linear-gradient(135deg, #333, #222);
            border-color: #666;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .orbButton:hover:not(:disabled)::before {
            width: 100%;
            height: 100%;
        }
        
        .orbButton:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        
        .orbButton:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        #teamDisplay {
    min-height: 240px;
    padding: 55px;
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: linear-gradient(135deg, rgba(26,26,26,0.95), rgba(13,13,13,0.95));
            border: 1px solid #333;
            border-radius: 15px;
            padding: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .teamSlot {
    display: inline-block;
    width: 95px;
    height: 185px;
    background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
    border: 1px solid #444;
    border-radius: 10px;
    margin: 5px;
    text-align: center;
    position: relative;
    padding: 5px;
    transition: all 0.2s;
    overflow: hidden; /* prevent overflow */
}
            background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
            border: 1px solid #444;
            border-radius: 10px;
            margin: 5px;
            text-align: center;
            position: relative;
            padding: 5px;
            transition: all 0.2s;
        }
        
        .teamSlot:hover {
            border-color: #666;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .teamSlotIcon {
            font-size: 32px;
            margin-bottom: 5px;
        }
        
        .teamSlotLevel {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 3px;
            font-weight: 500;
        }
        
        .teamSlotExpBar {
            width: 100%;
            height: 4px;
            background: #1a1a1a;
            border-radius: 2px;
            overflow: hidden;
            position: absolute;
            bottom: 5px;
            left: 0;
        }
        
        .teamSlotExpFill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #45a049);
            transition: width 0.3s;
        }
        
        #activityLog {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, rgba(26,26,26,0.95), rgba(13,13,13,0.95));
            border: 1px solid #333;
            border-radius: 15px;
            padding: 15px;
            max-width: 320px;
            max-height: 220px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
        }
        
        #activityLog::-webkit-scrollbar {
            width: 6px;
        }
        
        #activityLog::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 3px;
        }
        
        #activityLog::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 3px;
        }
        
        .logEntry {
            margin: 6px 0;
            padding: 8px 10px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            font-size: 13px;
            border-left: 3px solid #444;
            transition: all 0.2s;
        }
        
        .logEntry:hover {
            background: rgba(255,255,255,0.08);
            border-left-color: #4CAF50;
        }
        
        #backButton {
            position: absolute;
            top: 20px;
            left: 20px;
            background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
            border: 1px solid #444;
            color: #e0e0e0;
            padding: 12px 24px;
            border-radius: 10px;
            cursor: pointer;
            z-index: 20;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        #backButton:hover {
            background: linear-gradient(135deg, #333, #222);
            border-color: #666;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        #notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
            border: 1px solid #444;
            border-radius: 12px;
            padding: 20px 30px;
            display: none;
            z-index: 500;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
            animation: notificationPop 0.3s ease-out;
        }
        
        @keyframes notificationPop {
            from { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        
        #teamSelection {
            display: none;
            padding: 30px;
            background: linear-gradient(135deg, #1e1e1e, #141414);
            border-radius: 20px;
            max-width: 900px;
            margin: 0 auto;
            border: 1px solid #333;
            box-shadow: 0 20px 60px rgba(0,0,0,0.8);
            animation: fadeIn 0.5s ease-out;
        }
        
        #teamSelection h2 {
            margin: 0 0 25px 0;
            font-size: 28px;
            font-weight: 600;
            text-align: center;
        }
        
        #teamSelection h3 {
            margin: 25px 0 15px 0;
            font-size: 20px;
            font-weight: 500;
            color: #aaa;
        }
        
        #kinBankModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 300;
            overflow-y: auto;
            padding: 20px;
            backdrop-filter: blur(10px);
        }
        
        .kinBankContainer {
            max-width: 1400px;
            margin: 0 auto;
            background: linear-gradient(135deg, #1a1a1a, #0d0d0d);
            border-radius: 20px;
            padding: 30px;
            border: 1px solid #333;
            box-shadow: 0 20px 60px rgba(0,0,0,0.8);
        }
        
        .kinBankHeader {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 50px;
            padding-bottom: 20px;
            border-bottom: 2px solid #333;
        }
        
        .kinBankTitle {
            font-size: 36px;
            font-weight: bold;
            background: linear-gradient(45deg, #4CAF50, #2196F3);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .kinBankStats {
            display: flex;
            gap: 30px;
            align-items: center;
        }
        
        .kinBankStat {
            text-align: center;
            background: rgba(255,255,255,0.05);
            padding: 15px 25px;
            border-radius: 15px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .kinBankStatNumber {
            font-size: 28px;
            font-weight: bold;
            color: #4CAF50;
            margin-bottom: 5px;
        }
        
        .kinBankStatLabel {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .filterButtons {
            margin: 20px 0;
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: center;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
        }
        
        .filterButton {
            background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
            border: 2px solid #444;
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .filterButton:hover {
            background: linear-gradient(135deg, #333, #222);
            border-color: #666;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .filterButton.active {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            border-color: #4CAF50;
            box-shadow: 0 5px 20px rgba(76, 175, 80, 0.3);
        }
        
        .kinBankGrid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .kinBankCard {
            background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
            border: 2px solid #444;
            border-radius: 15px;
            padding: 0;
            cursor: pointer;
            transition: all 0.3s;
            overflow: visible;
            position: relative;
            height: 260px;
        }
        
        .kinBankCard:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border-color: #666;
        }
        
        .kinBankCard.radiant {
            border-color: gold;
            background: linear-gradient(135deg, #3a3a20, #2a2a10);
        }
        
        .kinBankCardHeader {
            background: rgba(0,0,0,0.3);
            padding: 12px 15px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            position: relative;
            z-index: 2;
        }
        
        .kinBankCardName {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 2px;
        }
        
        .kinBankCardLevel {
            font-size: 14px;
            color: #888;
        }
        
        .kinBankCardBody {
            padding: 5px 15px;
            position: relative;
            height: calc(100% - 65px);
        }
        
        .kinBankCardIcon {
            z-index: 0;
        }
        
        .kinBankCard:hover .kinBankCardIcon {
            opacity: 0.5;
        }
        
        .kinBankCard.radiant .kinBankCardIcon {
            opacity: 0.6;
            filter: drop-shadow(0 0 10px gold);
        }
        
        .kinBankCardStats {
            position: relative;
            z-index: 1;
            margin-bottom: 10px;
        }
        
        .kinBankCardStat {
            display: inline-block;
            background: rgba(0,0,0,0.6);
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 12px;
            margin: 2px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .kinBankCardActions {
            position: absolute;
            bottom: 15px;
            left: 15px;
            right: 15px;
            display: flex;
            gap: 8px;
            z-index: 2;
        }
        
        .kinBankCardButton {
            flex: 1;
            padding: 10px;
            background: linear-gradient(135deg, #333, #222);
            border: 1px solid #555;
            border-radius: 8px;
            color: white;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            font-weight: 500;
        }
        
        .kinBankCardButton:hover {
            background: linear-gradient(135deg, #444, #333);
            transform: translateY(-1px);
            border-color: #666;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        
        .kinBankCardButton.release {
            background: linear-gradient(135deg, #d32f2f, #b71c1c);
            border-color: #b71c1c;
        }
        
        .kinBankCardButton.release:hover {
            background: linear-gradient(135deg, #e53935, #c62828);
            border-color: #c62828;
            box-shadow: 0 2px 8px rgba(211, 47, 47, 0.3);
        }
        
        .kinBankOverallStat {
            position: absolute;
            top: 12px;
            right: 15px;
            background: rgba(0,0,0,0.8);
            padding: 5px 12px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            z-index: 3;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .kinGrid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .kinDexCard {
            background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
            border: 2px solid #444;
            border-radius: 12px;
            padding: 0;
            height: 180px;
            position: relative;
            overflow: hidden;
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .kinDexCard.caught {
            border-color: #4CAF50;
            background: linear-gradient(135deg, #2d3a2d, #1a1f1a);
        }
        
        .kinDexCard.caught.radiant {
            border-color: gold;
            background: linear-gradient(135deg, #3a3a20, #2a2a10);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
        }
        
        .kinDexCard:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.4);
        }
        
        .kinDexCardHeader {
            padding: 12px 15px;
            background: rgba(0,0,0,0.3);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .kinDexName {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 4px;
        }
        
        .kinDexType {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
.kinDexType.fire { color: #ff4444; }       /* Red for Fire */
.kinDexType.water { color: #4fc3f7; }      /* Blue for Water */
.kinDexType.earth { color: #81c784; }      /* Green for Earth */
.kinDexType.air { color: #ffffff; }        /* Bright White for Air */

        
        .kinDexIcon {
            position: absolute;
            bottom: 25px;
            right: 85px;
            right: 10px;
            font-size: 80px;
            opacity: 0.2;
            filter: grayscale(100%);
            transition: all 0.3s;
        
    margin-top: 8px;}
        
        .kinDexCard.caught .kinDexIcon {
            opacity: 1;
            bottom: -25px;
            filter: grayscale(0%);
            font-size: 90px;
        
    margin-top: 8px;}
        
        .kinDexRarity {
            position: absolute;
            top: 12px;
            right: 15px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 3px 8px;
            border-radius: 4px;
            background: rgba(0,0,0,0.5);
        }
        
        .kinDexStatus {
            position: absolute;
            bottom: 15px;
            left: 15px;
            font-size: 13px;
            font-weight: 500;
        }
        
        .kinDexStatus.caught {
            color: #4CAF50;
        }
        
        .kinDexStatus.notCaught {
            color: #666;
        }
        
        .kinDexRadiant {
            position: absolute;
            bottom: 35px;
            left: 15px;
            color: gold;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .kinDexNumber {
            position: absolute;
            top: 70px;
            left: 15px;
            font-size: 48px;
            font-weight: bold;
            color: rgba(255,255,255,0.1);
            font-family: monospace;
        }
        
        .kinDexCard.caught .kinDexNumber {
            color: rgba(255,255,255,0.2);
        }
        
        .kinDexHighStat {
            position: absolute;
            top: 35px;
            right: 15px;
            font-size: 11px;
            padding: 3px 8px;
            border-radius: 4px;
            background: rgba(0,0,0,0.5);
            cursor: help;
            transition: all 0.2s;
        }
        
        .kinDexHighStat:hover {
            background: rgba(0,0,0,0.8);
            transform: scale(1.05);
        }
        
        .kinDexHighStat .tooltip {
            visibility: hidden;
            position: absolute;
            top: -35px;
            right: 0;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 10px;
            white-space: nowrap;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .kinDexHighStat:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }
        
        .kinCardHeader {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .kinCardStats {
            font-size: 14px;
            margin: 5px 0;
        }
        
        .expBar {
            width: 100%;
            height: 6px;
            background: #222;
            border-radius: 3px;
            margin-top: 3px;
            overflow: hidden;
        }
        
        .expFill {
            height: 100%;
            background: #4CAF50;
            transition: width 0.3s;
        }
        
        .kinDetails {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2a2a2a;
            border: 3px solid #555;
            border-radius: 10px;
            padding: 20px;
            z-index: 400;
            min-width: 400px;
            display: none;
        }
        
        .teamSlotSelect {
            display: inline-block;
            width: 100px;
            height: 100px;
            background: #333;
            border: 3px solid #555;
            border-radius: 10px;
            margin: 10px;
            text-align: center;
            padding: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .teamSlotSelect:hover {
            background: #444;
            border-color: #777;
        }
        
        .teamSlotSelect.filled {
            border-color: #4CAF50;
        }
        
        .filterButtons {
            margin: 10px 0;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .filterButton {
            background: #444;
            border: 2px solid #666;
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .filterButton.active {
            background: #4CAF50;
            border-color: #4CAF50;
        }
        
        .kinAttacks {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #555;
            font-size: 12px;
        }
        
        .attackOption {
            margin: 2px 0;
            opacity: 0.6;
        }
        
        .attackOption.selected {
            opacity: 1;
            color: #4CAF50;
            font-weight: bold;
        }
        
        .protectorCard {
            background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
            border: 3px solid #555;
            border-radius: 15px;
            padding: 0;
            margin: 15px 0;
            overflow: hidden;
            transition: all 0.3s;
            position: relative;
            height: 140px;
        }
        
        .protectorCard:hover {
            transform: translateX(5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border-color: #777;
        }
        
        .protectorCard.defeated {
            background: linear-gradient(135deg, #2d3a2d, #1a1f1a);
            border-color: #4CAF50;
            opacity: 0.8;
        }
        
        .protectorCard.canChallenge {
            border-color: #666;
        }
        
        .protectorCard.locked {
            opacity: 0.6;
            border-color: #ff6666;
        }
        
        .protectorBadge {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 140px;
            background: rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-right: 1px solid rgba(255,255,255,0.1);
        }
        
        .protectorIcon {
            font-size: 60px;
            margin-bottom: 5px;
        }
        
        .protectorLevel {
            font-size: 14px;
            font-weight: 600;
            color: #888;
        }
        
        .protectorContent {
            margin-left: 140px;
            padding: 10px 20px;
            height: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .protectorInfo {
            flex: 1;
        }
        
        .protectorName {
            font-size: 22px;
            font-weight: bold;
            margin-bottom: 2px;
            color: #e0e0e0;
        }
        
        .protectorTeamInfo {
            font-size: 13px;
            color: #888;
            margin-bottom: 2px;
        }
        
        .protectorStatus {
            font-size: 14px;
            margin-bottom: 2px;
        }
        
        .protectorReward {
            background: rgba(0,0,0,0.3);
            padding: 4px 10px;
            border-radius: 8px;
            font-size: 13px;
            color: #4CAF50;
            display: inline-block;
            margin-top: 4px;
        }
        
        .protectorActions {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .defeatedBadge {
            background: #4CAF50;
            color: white;
            padding: 8px 16px;
            border-radius: 10px;
            font-weight: 600;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .biomeProtectors {
            margin-bottom: 40px;
        }
        
        .biomeProtectorsHeader {
            font-size: 26px;
            font-weight: bold;
            margin-bottom: 20px;
            padding: 15px 20px;
            background: linear-gradient(135deg, rgba(50,50,50,0.9), rgba(30,30,30,0.9));
            border-radius: 12px;
            display: flex;
            align-items: center;
            gap: 12px;
            position: relative;
            overflow: hidden;
        }
        
        .biomeProtectorsHeader::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.05), transparent);
            animation: shimmer 3s infinite;
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .biomeCompletion {
            position: absolute;
            right: 20px;
            font-size: 14px;
            color: #888;
            font-weight: normal;
        }
        
        .biomeCompletion.complete {
            color: #4CAF50;
        }
        
        /* Save/Load Modal */
        #saveLoadModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 300;
            overflow-y: auto;
            padding: 20px;
            backdrop-filter: blur(10px);
        }
        
        .saveLoadContainer {
            max-width: 800px;
            margin: 0 auto;
            background: linear-gradient(135deg, #1a1a1a, #0d0d0d);
            border-radius: 20px;
            padding: 30px;
            border: 1px solid #333;
            box-shadow: 0 20px 60px rgba(0,0,0,0.8);
        }
        
        .saveLoadHeader {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 50px;
            padding-bottom: 20px;
            border-bottom: 2px solid #333;
        }
        
        .saveLoadTitle {
            font-size: 32px;
            font-weight: bold;
            background: linear-gradient(45deg, #4CAF50, #2196F3);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .saveLoadSection {
            margin: 30px 0;
            padding: 25px;
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .saveLoadSection h3 {
            margin: 0 0 15px 0;
            font-size: 22px;
            color: #e0e0e0;
        }
        
        .saveLoadSection p {
            margin: 0 0 15px 0;
            color: #888;
            font-size: 14px;
        }
        
        .saveCodeArea {
            width: 100%;
            min-height: 100px;
            background: #0a0a0a;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 15px;
            font-family: monospace;
            font-size: 12px;
            color: #4CAF50;
            resize: vertical;
            margin: 15px 0;
        }
        
        .saveLoadButtons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .saveLoadButtons button {
            padding: 12px 24px;
            background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
            border: 1px solid #444;
            color: #e0e0e0;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            font-weight: 500;
        }
        
        .saveLoadButtons button:hover {
            background: linear-gradient(135deg, #333, #222);
            border-color: #666;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .saveLoadButtons button.primary {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            border-color: #4CAF50;
        }
        
        .saveLoadButtons button.primary:hover {
            background: linear-gradient(135deg, #45a049, #3d8b40);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }
        
        .saveLoadButtons button.danger {
            background: linear-gradient(135deg, #d32f2f, #b71c1c);
            border-color: #b71c1c;
        }
        
        .saveLoadButtons button.danger:hover {
            background: linear-gradient(135deg, #e53935, #c62828);
            box-shadow: 0 4px 12px rgba(211, 47, 47, 0.3);
        }
        
        .saveInfo {
            margin: 20px 0;
            padding: 15px;
            background: rgba(76, 175, 80, 0.1);
            border: 1px solid rgba(76, 175, 80, 0.3);
            border-radius: 8px;
            font-size: 14px;
            display: none;
        }
        
        .saveInfo.show {
            display: block;
        }15px;
            padding: 30px;
            z-index: 600;
            text-align: center;
            min-width: 350px;
            box-shadow: 0 15px 50px rgba(0,0,0,0.8);
        }
        
        #releaseConfirmModal h3 {
            margin: 0 0 20px 0;
            color: #ff6666;
            font-size: 22px;
        }
        
        #releaseConfirmModal p {
            margin: 0 0 25px 0;
            font-size: 16px;
            color: #ddd;
        }
        
        .releaseConfirmButtons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }
        
        .releaseConfirmButtons button {
            padding: 12px 30px;
            border-radius: 8px;
            border: none;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .confirmReleaseBtn {
            background: linear-gradient(135deg, #d32f2f, #b71c1c);
            color: white;
        }
        
        .confirmReleaseBtn:hover {
            background: linear-gradient(135deg, #e53935, #c62828);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(211, 47, 47, 0.4);
        }
        
        .cancelReleaseBtn {
            background: linear-gradient(135deg, #555, #333);
            color: white;
        }
        
        .cancelReleaseBtn:hover {
            background: linear-gradient(135deg, #666, #444);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="header">
            <div id="title">KinBound</div>
            <div id="resources">
                <div class="resource">
                    <span>💰</span>
                    <span id="goldCount">0</span>
                </div>
                <div class="orbsContainer">
                    <div class="orbType">
                        <span class="orbIcon">⚪</span>
                        <span id="commonOrbCount">10</span>
                    </div>
                    <div class="orbType">
                        <span class="orbIcon">🟢</span>
                        <span id="greatOrbCount">1</span>
                    </div>
                    <div class="orbType">
                        <span class="orbIcon">🔵</span>
                        <span id="rareOrbCount">0</span>
                    </div>
                    <div class="orbType">
                        <span class="orbIcon">🟣</span>
                        <span id="epicOrbCount">0</span>
                    </div>
                    <div class="orbType">
                        <span class="orbIcon">⭐</span>
                        <span id="legendaryOrbCount">0</span>
                    </div>
                </div>
                <div class="resource">
                    <span>📦</span>
                    <span id="kinDexCount">0/100</span>
                </div>
            </div>
        </div>
        
        <div id="mainArea">
            <div id="biomeSelection">
                <div class="biomeCard" data-biome="fire">
                    <div class="biomeIcon">🔥</div>
                    <div class="biomeName">The Ashen Peaks</div>
                    <div class="biomeDesc">Volcanic terrain</div>
                    <div class="biomeTimer"></div>
                </div>
                <div class="biomeCard" data-biome="water">
                    <div class="biomeIcon">💧</div>
                    <div class="biomeName">The Sunken Grotto</div>
                    <div class="biomeDesc">Flooded caverns</div>
                    <div class="biomeTimer"></div>
                </div>
                <div class="biomeCard" data-biome="earth">
                    <div class="biomeIcon">🌍</div>
                    <div class="biomeName">The Tectonic Scar</div>
                    <div class="biomeDesc">Rocky terrain</div>
                    <div class="biomeTimer"></div>
                </div>
                <div class="biomeCard" data-biome="air">
                    <div class="biomeIcon">💨</div>
                    <div class="biomeName">The Howling Spires</div>
                    <div class="biomeDesc">Windy heights</div>
                    <div class="biomeTimer"></div>
                </div>
                <div style="grid-column: span 2; text-align: center; margin-top: 20px; display: flex; gap: 20px; justify-content: center;">
                    <button class="orbButton" onclick="openKinBank()">KinBank</button>
                    <button class="orbButton" onclick="openKinDex()">KinDex</button>
                    <button class="orbButton" onclick="openKinBag()">KinBag</button>
                    <button class="orbButton" onclick="openChallenges()">Challenges</button>
                    <button class="orbButton" onclick="openSaveLoad()">Save/Load</button>
                </div>
            </div>
            
            <div id="teamSelection">
                <h2>Select Your Team</h2>
                <div style="text-align: center; margin: 20px 0;">
                    <div id="selectedTeamDisplay"></div>
                </div>
                <div>
                    <h3>Available Kin:</h3>
                    
    <div style="margin: 20px 0;">
        <div style="display: flex; gap: 15px; flex-wrap: wrap; align-items: center; justify-content: center; margin-bottom: 10px;">
            <label style="color: #ccc;">Filter by Element:</label>
            <select id="filterElement" onchange="updateTeamSelectionDisplay()">
                <option value="all">All</option>
                <option value="fire">Fire</option>
                <option value="water">Water</option>
                <option value="earth">Earth</option>
                <option value="air">Air</option>
            </select>

            <label style="color: #ccc;">Sort By:</label>
            <select id="sortOption" onchange="updateTeamSelectionDisplay()">
                <option value="overall">Best Overall</option>
                <option value="level">Level</option>
                <option value="rarity">Rarity</option>
                <option value="name">Name</option>
            </select>
        </div>
        <div id="availableKinList" style="max-height: 300px; overflow-y: auto; padding: 10px; border: 1px solid #333; border-radius: 10px;"></div>
    </div>
    
                </div>
                <div style="text-align: center; margin-top: 20px;">
                    <button class="orbButton" onclick="confirmTeamAndExplore()">Start Exploring</button>
                    <button class="orbButton" onclick="cancelTeamSelection()">Cancel</button>
                </div>
            </div>
            
            <div id="explorationArea">
                <div id="biomeBackground"></div>
                <div id="player" class="player-idle">
                    <div class="playerSprite">
                        <div class="playerHead"></div>
                        <div class="playerBody"></div>
                        <div class="playerArm left"></div>
                        <div class="playerArm right"></div>
                        <div class="playerLeg left"></div>
                        <div class="playerLeg right"></div>
                    </div>
                </div>
                <button id="backButton">Leave Biome</button>
                <div id="teamDisplay"></div>
                <div id="activityLog"></div>
                
                <!-- Biome Info in bottom right -->
                <div id="biomeInfo">
                    <div id="biomeName">
                        <span id="biomeIcon">🔥</span>
                        <span id="biomeNameText">The Ashen Peaks</span>
                    </div>
                    <div class="biomeProgressBar">
                        <div class="biomeProgressFill" id="biomeProgressFill"></div>
                    </div>
                    <div class="biomeStats">
                        <div class="biomeStat">
                            <div class="biomeStatNumber" id="caughtCount">0</div>
                            <div class="biomeStatLabel">Caught</div>
                        </div>
                        <div class="biomeStat">
                            <div class="biomeStatNumber" id="totalBiomeKin" style="color: #888;">0</div>
                            <div class="biomeStatLabel">Total</div>
                        </div>
                        <div class="biomeStat">
                            <div class="biomeStatNumber" id="completionPercent" style="color: #2196F3;">0%</div>
                            <div class="biomeStatLabel">Complete</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="encounterModal">
            <div id="encounterContent"></div>
        </div>
        
        <div id="notification"></div>
        
        <div id="kinBankModal">
            <div class="kinBankContainer">
                <div class="kinBankHeader">
                    <div>
                        <h2 class="kinBankTitle">KinBank</h2>
                        <div style="color: #888; font-size: 16px; margin-top: 5px;">Your collection of captured Kin</div>
                    </div>
                    <div class="kinBankStats">
                        <div class="kinBankStat">
                            <div class="kinBankStatNumber" id="totalCaught">0</div>
                            <div class="kinBankStatLabel">Total Kin</div>
                        </div>
                        <div class="kinBankStat">
                            <div class="kinBankStatNumber" id="radiantCount" style="color: gold;">0</div>
                            <div class="kinBankStatLabel">Radiant</div>
                        </div>
                        <button class="orbButton" onclick="closeKinBank()" style="height: fit-content;">Close</button>
                    </div>
                </div>
                
                <div class="filterButtons">
                    <button class="filterButton active" onclick="filterKinBank('all')">
                        <span>All Kin</span>
                    </button>
                    <button class="filterButton" onclick="filterKinBank('fire')">
                        <span>🔥</span>
                        <span>Fire</span>
                    </button>
                    <button class="filterButton" onclick="filterKinBank('water')">
                        <span>💧</span>
                        <span>Water</span>
                    </button>
                    <button class="filterButton" onclick="filterKinBank('earth')">
                        <span>🌍</span>
                        <span>Earth</span>
                    </button>
                    <button class="filterButton" onclick="filterKinBank('air')">
                        <span>💨</span>
                        <span>Air</span>
                    </button>
                    <button class="filterButton" onclick="filterKinBank('radiant')">
                        <span>✨</span>
                        <span>Radiant</span>
                    </button>
                </div>
                
                <div id="kinBankGrid" class="kinBankGrid"></div>
            </div>
        </div>
        
        <div id="kinDetails" class="kinDetails">
            <div id="kinDetailsContent"></div>
            <button class="orbButton" onclick="closeKinDetails()" style="margin-top: 20px;">Close</button>
        </div>
        
        <div id="kinDexModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 300; overflow-y: auto; padding: 20px;">
            <div class="kinBankContainer">
                <div class="kinBankHeader">
                    <div>
                        <h2 class="kinBankTitle">KinDex</h2>
                    </div>
                    <button class="orbButton" onclick="closeKinDex()" style="height: fit-content;">Close</button>
                </div>
                
                <!-- Statistics Section -->
                <div style="background: rgba(255,255,255,0.05); border-radius: 15px; padding: 20px; margin-bottom: 50px; border: 1px solid rgba(255,255,255,0.1);">
                    <h3 style="margin: 0 0 20px 0; font-size: 24px; text-align: center;">Game Statistics</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                        <div class="kinBankStat">
                            <div class="kinBankStatNumber" id="totalEncountered">0</div>
                            <div class="kinBankStatLabel">Kin Seen</div>
                        </div>
                        <div class="kinBankStat">
                            <div class="kinBankStatNumber" id="totalCaughtStat">0</div>
                            <div class="kinBankStatLabel">Kin Caught</div>
                        </div>
                        <div class="kinBankStat">
                            <div class="kinBankStatNumber" id="catchRate" style="color: #2196F3;">0%</div>
                            <div class="kinBankStatLabel">Catch Rate</div>
                        </div>
                        <div class="kinBankStat">
                            <div class="kinBankStatNumber" id="radiantEncountered" style="color: gold;">0</div>
                            <div class="kinBankStatLabel">Radiant Seen</div>
                        </div>
                        <div class="kinBankStat">
                            <div class="kinBankStatNumber" id="radiantCaughtStat" style="color: gold;">0</div>
                            <div class="kinBankStatLabel">Radiant Caught</div>
                        </div>
                        <div class="kinBankStat">
                            <div class="kinBankStatNumber" id="totalGold" style="color: #FFD700;">0</div>
                            <div class="kinBankStatLabel">Gold Earned</div>
                        </div>
                    </div>
                    
                    <!-- Police Battle Stats -->
                    <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.1);">
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
                            <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px;">
                                <div style="font-size: 16px; margin-bottom: 10px;">Police Battles</div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span>Won: <strong style="color: #4CAF50;" id="policeWon">0</strong></span>
                                    <span>Lost: <strong style="color: #ff6666;" id="policeLost">0</strong></span>
                                    <span>Win Rate: <strong style="color: #2196F3;" id="policeWinRate">0%</strong></span>
                                </div>
                            </div>
                            <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px;">
                                <div style="font-size: 16px; margin-bottom: 10px;">Boxes Found</div>
                                <div style="text-align: center;">
                                    <span style="font-size: 24px; font-weight: bold; color: #9C27B0;" id="totalBoxes">0</span>
                                </div>
                            </div>
                            <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px;">
                                <div style="font-size: 16px; margin-bottom: 10px;">Orbs Used</div>
                                <div style="display: flex; justify-content: space-around; align-items: center; font-size: 14px;">
                                    <span title="Common">⚪ <strong id="commonOrbsUsed">0</strong></span>
                                    <span title="Great">🟢 <strong id="greatOrbsUsed">0</strong></span>
                                    <span title="Rare">🔵 <strong id="rareOrbsUsed">0</strong></span>
                                    <span title="Epic">🟣 <strong id="epicOrbsUsed">0</strong></span>
                                    <span title="Legendary">⭐ <strong id="legendaryOrbsUsed">0</strong></span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <div>
                        <div>Progress: <span id="dexProgress">0/100</span></div>
                    </div>
                </div>
                <div id="kinDexGrid" class="kinGrid"></div>
            </div>
        </div>
        
        <div id="kinBagModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 300; overflow-y: auto; padding: 20px;">
            <div class="kinBankContainer">
                <h2>KinBag</h2>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <button class="orbButton" onclick="closeKinBag()">Close</button>
                </div>
                <div id="kinBagContent" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px; margin-top: 20px;"></div>
            </div>
        </div>
        
        <div id="challengesModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 300; overflow-y: auto; padding: 20px;">
            <div class="kinBankContainer">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <button class="orbButton" onclick="closeChallenges()" style="margin-left: auto;">Close</button>
                </div>
                <div id="challengesContent"></div>
            </div>
        </div>
        
        <!-- Save/Load Modal -->
        <div id="saveLoadModal">
            <div class="saveLoadContainer">
                <div class="saveLoadHeader">
                    <h2 class="saveLoadTitle">Save & Load Game</h2>
                    <button class="orbButton" onclick="closeSaveLoad()">Close</button>
                </div>
                
                <!-- Auto-Save Section -->
                <div class="saveLoadSection">
                    <h3>🔄 Auto-Save</h3>
                    <p>Your game is automatically saved to your browser's local storage.</p>
                    <div id="autoSaveInfo" class="saveInfo">
                        <!-- Auto-save info will be inserted here -->
                    </div>
                    <div class="saveLoadButtons">
                        <button class="primary" onclick="saveToLocalStorage()">💾 Save Now</button>
                        <button onclick="loadFromLocalStorage()">📂 Load from Browser</button>
                        <button class="danger" onclick="clearLocalStorage()">🗑️ Clear Browser Save</button>
                    </div>
                </div>
                
                <!-- Manual Save Section -->
                <div class="saveLoadSection">
                    <h3>💾 Manual Save/Load</h3>
                    <p>Download your save file or load a previously downloaded save. Use this as a backup!</p>
                    <div class="saveLoadButtons">
                        <button class="primary" onclick="downloadSave()">⬇️ Download Save File</button>
                        <input type="file" id="saveFileInput" accept=".kinbound" style="display: none;" onchange="uploadSave(event)">
                        <button onclick="document.getElementById('saveFileInput').click()">⬆️ Upload Save File</button>
                    </div>
                </div>
            </div>
        </div>
        
    </div>

    <script>
        
function getKinVisual(kin, size = 80) {
    if (kin.image) {
        return `<img src="${kin.image}" alt="${kin.name}" style="width:${size}px;height:${size}px;image-rendering:pixelated;">`;
    } else {
        return getKinVisual(kin, 120);
    }
}

// Game State
        const gameState = {
            gold: 0,
            orbs: {
                common: 10,
                great: 1,
                rare: 0,
                epic: 0,
                legendary: 0
            },
            currentBiome: null,
            biomeBans: {
                fire: 0,
                water: 0,
                earth: 0,
                air: 0
            },
            team: [],
            kinBank: [],
            kinDex: new Set(),
            radiantDex: new Set(),
            exploring: false,
            encounterActive: false,
            nextEncounterTime: 0,
            nextSpecialTime: 0,
            nextBoxTime: 0,
            totalKinCaught: 0,
            protectorsDefeated: {
                fire: [],
                water: [],
                earth: [],
                air: []
            },
            activeEffects: {
                radiantCollector: 0,  // Timestamp when it expires
                lures: {
                    fire: 0,   // Timestamp when it expires
                    water: 0,
                    earth: 0,
                    air: 0
                }
            },
            // New statistics tracking
            stats: {
                totalKinEncountered: 0,
                totalRadiantEncountered: 0,
                totalGoldEarned: 0,
                policeBattlesWon: 0,
                policeBattlesLost: 0,
                protectorBattlesWon: 0,
                protectorBattlesLost: 0,
                totalBoxesFound: 0,
                orbsUsed: {
                    common: 0,
                    great: 0,
                    rare: 0,
                    epic: 0,
                    legendary: 0
                }
            }
        };

        // Give starter Kin
        function giveStarterKin() {
            // Pick random element and common Kin
            const elements = ['fire', 'water', 'earth', 'air'];
            const randomElement = elements[Math.floor(Math.random() * elements.length)];
            const commonKin = kinDatabase[randomElement].common;
            const starterBase = commonKin[Math.floor(Math.random() * commonKin.length)];
            
            // Generate stats in bottom 50% of common range
            const ranges = {
                hp: [120, 160], // Bottom half of 120-200
                attack: [15, 22], // Bottom half of 15-29
                speed: [12, 19], // Bottom half of 12-26
                crit: [5, 7] // Bottom half of 5-10
            };
            
            const starter = {
                ...starterBase,
                element: randomElement,
                rarity: 'common',
                isRadiant: false,
                level: 1,
                exp: 0,
                stats: {
                    hp: randomBetween(ranges.hp[0], ranges.hp[1]),
                    attack: randomBetween(ranges.attack[0], ranges.attack[1]),
                    speed: randomBetween(ranges.speed[0], ranges.speed[1]),
                    crit: randomBetween(ranges.crit[0], ranges.crit[1])
                },
                attack: getRandomAttack()
            };
            
            // Add to bank and team
            gameState.kinBank.push(starter);
            gameState.team.push(starter);
            gameState.kinDex.add(starter.id);
            gameState.totalKinCaught = 1;
            
            return starter;
        }

        // Kin Database - 100 unique Kin (25 per biome)
        const kinDatabase = {
            fire: {
                common: [
                    { id: 'bristlepup', name: 'Bristlepup', icon: '🐕' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Fire/bristlepup.png' },
                    { id: 'kindro', name: 'Kindro', icon: '🦎' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Fire/kindro.png' },
                    { id: 'fennix', name: 'Fennix', icon: '🐭' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Fire/fennix.png' },
                    { id: 'scindle', name: 'Scindle', icon: '🦊' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Fire/scindle.png' },
                    { id: 'wiskit', name: 'Wiskit', icon: '🦇' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Fire/wiskit.png' },
                    { id: 'latcha', name: 'Latcha', icon: '🐰' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Fire/latcha.png' },
                    { id: 'vixu', name: 'Vixu', icon: '🐱' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Fire/vixu.png' },
                    { id: 'crimbee', name: 'Crimbee', icon: '🐝' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Fire/crimbee.png' },
                    { id: 'pikkit', name: 'Pikkit', icon: '🐸' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Fire/pikkit.png' },
                    { id: 'gritbun', name: 'Gritbun', icon: '🐹' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Fire/gritbun.png' }
                ],
                uncommon: [
                    { id: 'houndren', name: 'Houndren', icon: '🐢' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Fire/houndren.png' },
                    { id: 'varnowl', name: 'Varnowl', icon: '🦉' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Fire/varnowl.png' },
                    { id: 'moltara', name: 'Moltara', icon: '🐺' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Fire/moltara.png' },
                    { id: 'braxen', name: 'Braxen', icon: '🐻' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Fire/braxen.png' },
                    { id: 'cindor', name: 'Cindor', icon: '🦂' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Fire/cindor.png' },
                    { id: 'quenra', name: 'Quenra', icon: '🦅' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Fire/quenra.png' },
                    { id: 'zaffra', name: 'Zaffra', icon: '🌵' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Fire/zaffra.png' },
                    { id: 'ignishade', name: 'Ignishade', icon: '🦩' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Fire/ignishade.png' },
                ],
                rare: [
                    { id: 'vaelion', name: 'Vaelion', icon: '🦜' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Fire/vaelion.png' },
                    { id: 'draxir', name: 'Draxir', icon: '🐲' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Fire/draxir.png' },
                    { id: 'solmere', name: 'Solmere', icon: '🦁' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Fire/solmere.png' },
                    { id: 'fyrion', name: 'Fyrion', icon: '🌋' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Fire/fyrion.png' },
                    { id: 'quarnyx', name: 'Quarnyx', icon: '🐅' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Fire/quarnyx.png' },
                ],
                epic: [
                    { id: 'brimlor', name: 'Brimlor', icon: '🐉' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Fire/brimlor.png' },
                    { id: 'ashkara', name: 'Ashkara', icon: '☄️' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Fire/ashkara.png' },
                ]
            },
            water: {
                common: [
                    { id: 'minnu', name: 'Minnu', icon: '🐟' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Water/minnu.png' },
                    { id: 'glibby', name: 'Glibby', icon: '💧' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Water/glibby.png' },
                    { id: 'slooplet', name: 'Slooplet', icon: '🐕' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Water/slooplet.png' },
                    { id: 'nibbletide', name: 'Nibbletide', icon: '🐀' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Water/nibbletide.png' },
                    { id: 'wandra', name: 'Wandra', icon: '🐍' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Water/wandra.png' },
                    { id: 'lumra', name: 'Lumra', icon: '🐸' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Water/lumra.png' },
                    { id: 'pepple', name: 'Pepple', icon: '🦋' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Water/pepple.png' },
                    { id: 'quabble', name: 'Quabble', icon: '🐇' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Water/quabble.png' },
                    { id: 'dreef', name: 'Dreef', icon: '🫧' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Water/dreef.png' },
                    { id: 'dapduck', name: 'Dapduck', icon: '🦆' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Water/dapduck.png' },
                ],
                uncommon: [
                    { id: 'brackel', name: 'Brackel', icon: '🦀' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Water/brackel.png' },
                    { id: 'surflynx', name: 'Surflynx', icon: '🦈' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Water/surflynx.png' },
                    { id: 'kelpure', name: 'Kelpure', icon: '🦦' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Water/kelpure.png' },
                    { id: 'nuvin', name: 'Nuvin', icon: '🦭' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Water/nuvin.png' },
                    { id: 'glimseal', name: 'Glimseal', icon: '🐢' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Water/glimseal.png' },
                    { id: 'twalow', name: 'Twalow', icon: '🐧' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Water/twalow.png' },
                    { id: 'veleena', name: 'Veleena', icon: '🪼' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Water/veleena.png' },
                    { id: 'moondra', name: 'Moondra', icon: '🐙' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Water/moondra.png' },
                ],
                rare: [
                    { id: 'kyrava', name: 'Kyrava', icon: '🐋' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Water/kyrava.png' },
                    { id: 'thalorin', name: 'Thalorin', icon: '🦈' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Water/thalorin.png' },
                    { id: 'miralune', name: 'Miralune', icon: '🐉' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Water/miralune.png' },
                    { id: 'nymbark', name: 'Nymbark', icon: '🦄' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Water/nymbark.png' },
                    { id: 'brineth', name: 'Brineth', icon: '🦪' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Water/brineth.png' },
                ],
                epic: [
                    { id: 'abyrel', name: 'Abyrel', icon: '🌊' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Water/abyrel.png' },
                    { id: 'typharos', name: 'Typharos', icon: '🦑' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Water/typharos.png' },
                ]
            },
            earth: {
                common: [
                    { id: 'grubbin', name: 'Grubbin', icon: '🪨' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Earth/grubbin.png' },
                    { id: 'pebbix', name: 'Pebbix', icon: '🐕' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Earth/pebbix.png' },
                    { id: 'dozbit', name: 'Dozbit', icon: '🐁' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Earth/dozbit.png' },
                    { id: 'clatch', name: 'Clatch', icon: '🦫' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Earth/clatch.png' },
                    { id: 'ruffel', name: 'Ruffel', icon: '🐌' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Earth/ruffel.png' },
                    { id: 'rumblet', name: 'Rumblet', icon: '🐈' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Earth/rumblet.png' },
                    { id: 'grozzle', name: 'Grozzle', icon: '🐰' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Earth/grozzle.png' },
                    { id: 'trenna', name: 'Trenna', icon: '🐸' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Earth/trenna.png' },
                    { id: 'klomp', name: 'Klomp', icon: '🪱' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Earth/klomp.png' },
                    { id: 'duzzit', name: 'Duzzit', icon: '🪳' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Earth/duzzit.png' },
                ],
                uncommon: [
                    { id: 'grallum', name: 'Grallum', icon: '🐻' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Earth/grallum.png' },
                    { id: 'quornak', name: 'Quornak', icon: '🐺' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Earth/quornak.png' },
                    { id: 'staldir', name: 'Staldir', icon: '🐐' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Earth/staldir.png' },
                    { id: 'tarmox', name: 'Tarmox', icon: '🐪' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Earth/tarmox.png' },
                    { id: 'bollo', name: 'Bollo', icon: '🦔' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Earth/bollo.png' },
                    { id: 'chundra', name: 'Chundra', icon: '🐍' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Earth/chundra.png' },
                    { id: 'felnok', name: 'Felnok', icon: '🐂' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Earth/felnok.png' },
                    { id: 'krozbit', name: 'Krozbit', icon: '🦀' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Earth/krozbit.png' },
                ],
                rare: [
                    { id: 'vaedrax', name: 'Vaedrax', icon: '🦌' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Earth/vaedrax.png' },
                    { id: 'tharnox', name: 'Tharnox', icon: '💎' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Earth/tharnox.png' },
                    { id: 'rugolith', name: 'Rugolith', icon: '🦖' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Earth/rugolith.png' },
                    { id: 'drandor', name: 'Drandor', icon: '👑' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Earth/drandor.png' },
                    { id: 'jorrak', name: 'Jorrak', icon: '🗿' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Earth/jorrak.png' },
                ],
                epic: [
                    { id: 'mogralith', name: 'Mogralith', icon: '⛰️' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Earth/mogralith.png' },
                    { id: 'karzen', name: 'Karzen', icon: '🌍' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Earth/karzen.png' },
                ]
            },
            air: {
                common: [
                    { id: 'flitta', name: 'Flitta', icon: '🦋' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Air/flitta.png' },
                    { id: 'skibbin', name: 'Skibbin', icon: '🐥' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Air/skibbin.png' },
                    { id: 'zeffi', name: 'Zeffi', icon: '🦫' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Air/zeffi.png' },
                    { id: 'loofin', name: 'Loofin', icon: '🐇' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Air/loofin.png' },
                    { id: 'quist', name: 'Quist', icon: '🐦' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Air/quist.png' },
                    { id: 'tuffit', name: 'Tuffit', icon: '🐭' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Air/tuffit.png' },
                    { id: 'plumee', name: 'Plumee', icon: '🐜' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Air/plumee.png' },
                    { id: 'whisbit', name: 'Whisbit', icon: '🕊️' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Air/whisbit.png' },
                    { id: 'brivvy', name: 'Brivvy', icon: '🦫' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Air/brivvy.png' },
                    { id: 'preep', name: 'Preep', icon: '🦇' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Air/preep.png' },
                ],
                uncommon: [
                    { id: 'aerowit', name: 'Aerowit', icon: '🦅' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Air/aerowit.png' },
                    { id: 'vinterra', name: 'Vinterra', icon: '🦁' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Air/vinterra.png' },
                    { id: 'skyrrel', name: 'Skyrrel', icon: '🪿' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Air/skyrrel.png' },
                    { id: 'fandrel', name: 'Fandrel', icon: '🦊' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Air/fandrel.png' },
                    { id: 'wavren', name: 'Wavren', icon: '🦅' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Air/wavren.png' },
                    { id: 'draela', name: 'Draela', icon: '🕷️' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Air/draela.png' },
                    { id: 'nyffi', name: 'Nyffi', icon: '🦢' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Air/nyffi.png' },
                    { id: 'clistral', name: 'Clistral', icon: '🦉' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Air/clistral.png' },
                ],
                rare: [
                    { id: 'yuralon', name: 'Yuralon', icon: '🦅' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Air/yuralon.png' },
                    { id: 'siroth', name: 'Siroth', icon: '🐲' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Air/siroth.png' },
                    { id: 'arvent', name: 'Arvent', icon: '🦜' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Air/arvent.png' },
                    { id: 'vailume', name: 'Vailume', icon: '⚡' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Air/vailume.png' },
                    { id: 'zenth', name: 'Zenth', icon: '🌟' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Air/zenth.png' },
                ],
                epic: [
                    { id: 'altirion', name: 'Altirion', icon: '🌪️' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Air/altirion.png' },
                    { id: 'venthos', name: 'Venthos', icon: '👑' , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Air/venthos.png' },
                ]
            }
        };

        // Utility Functions
        function randomBetween(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        
        function getExpNeeded(level) {
            if (level <= 10) return 100;
            if (level <= 20) return 200;
            if (level <= 30) return 400;
            if (level <= 40) return 600;
            return 600; // Max level
        }

        function showNotification(message, duration = 2000) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.style.display = 'block';
            setTimeout(() => {
                notification.style.display = 'none';
            }, duration);
        }

        function updateDisplay() {
            document.getElementById('goldCount').textContent = gameState.gold;
            
            // Update individual orb counts
            document.getElementById('commonOrbCount').textContent = gameState.orbs.common;
            document.getElementById('greatOrbCount').textContent = gameState.orbs.great;
            document.getElementById('rareOrbCount').textContent = gameState.orbs.rare;
            document.getElementById('epicOrbCount').textContent = gameState.orbs.epic;
            document.getElementById('legendaryOrbCount').textContent = gameState.orbs.legendary;
            
            document.getElementById('kinDexCount').textContent = `${gameState.kinDex.size}/100`;
            
            // Update active effects display
            updateActiveEffectsDisplay();
        }
        
        function updateBiomeInfo() {
            if (!gameState.currentBiome) return;
            
            // Get biome icon
            const biomeIcons = { fire: '🔥', water: '💧', earth: '🌍', air: '💨' };
            
            // Update biome name and icon
            const biomeIcon = document.getElementById('biomeIcon');
            const biomeNameText = document.getElementById('biomeNameText');
            if (biomeIcon) biomeIcon.textContent = biomeIcons[gameState.currentBiome];
            if (biomeNameText) biomeNameText.textContent = getBiomeName(gameState.currentBiome);
            
            // Count caught and total Kin in current biome
            let caughtCount = 0;
            let totalCount = 0;
            
            Object.keys(kinDatabase[gameState.currentBiome]).forEach(rarity => {
                kinDatabase[gameState.currentBiome][rarity].forEach(kin => {
                    totalCount++;
                    if (gameState.kinDex.has(kin.id)) {
                        caughtCount++;
                    }
                });
            });
            
            // Calculate completion percentage
            const completionPercent = totalCount > 0 ? Math.round((caughtCount / totalCount) * 100) : 0;
            
            // Update displays
            const caughtElement = document.getElementById('caughtCount');
            const totalElement = document.getElementById('totalBiomeKin');
            const percentElement = document.getElementById('completionPercent');
            const progressFill = document.getElementById('biomeProgressFill');
            
            if (caughtElement) caughtElement.textContent = caughtCount;
            if (totalElement) totalElement.textContent = totalCount;
            if (percentElement) percentElement.textContent = `${completionPercent}%`;
            if (progressFill) progressFill.style.width = `${completionPercent}%`;
        }

        function updateTeamDisplay() {
            const teamDisplay = document.getElementById('teamDisplay');
            if (!teamDisplay) return; // Exit if element doesn't exist yet
            
            const elements = ['fire', 'water', 'earth', 'air'];
            const icons = { fire: '🔥', water: '💧', earth: '🌍', air: '💨' };
            
            teamDisplay.innerHTML = `
                <div style="font-size: 14px; font-weight: bold;">Your Team:</div>
                <div style="display: flex; gap: 5px;">
            `;
            
            gameState.team.forEach(kin => {
                const slot = document.createElement('div');
                slot.className = 'teamSlot';
                
                const level = kin.level || 1;
                const exp = kin.exp || 0;
                const expNeeded = getExpNeeded(level);
                const expPercent = (exp / expNeeded) * 100;
                
                slot.innerHTML = `
                    <div style="position: absolute; top: 2px; right: 2px; font-size: 12px; opacity: 0.7;">
                        ${icons[kin.element]}
                    </div>
                    <div class="teamSlotLevel">Lv.${level}</div>
                    <div class="teamSlotExpBar" style="margin-bottom: 2px;">
                        <div class="teamSlotExpFill" style="width: ${expPercent}%"></div>
                    </div>
                    <div class="teamSlotIcon" style="overflow: hidden; display: flex; align-items: center; justify-content: center; height: 90px; margin-top: 16px;">${getKinVisual(kin, 80) || icons[kin.element || 'fire']}</div>
                    <div style="font-size: 11px; font-weight: bold; margin-top: 10px;">${kin.name}</div>
                    <div style="font-size: 10px; color: #666; position: absolute; bottom: 10px; width: 100%; left: 0;">
                        ${exp}/${expNeeded}
                    </div>
                `;
                teamDisplay.querySelector('div:last-child').appendChild(slot);
            });
            
            // Empty slots
            for (let i = gameState.team.length; i < 4; i++) {
                const slot = document.createElement('div');
                slot.className = 'teamSlot';
                slot.innerHTML = '<div style="font-size: 30px; margin-top: 25px;">-</div>';
                teamDisplay.querySelector('div:last-child').appendChild(slot);
            }
            
            teamDisplay.innerHTML += '</div>';
        }
        
        function updateActiveEffectsDisplay() {
            const now = Date.now();
            const header = document.getElementById('header');
            
            // Remove existing effects display
            const existingEffects = document.getElementById('activeEffects');
            if (existingEffects) existingEffects.remove();
            
            const activeEffects = [];
            
            // Check Radiant Collector
            if (gameState.activeEffects.radiantCollector > now) {
                const remaining = Math.ceil((gameState.activeEffects.radiantCollector - now) / 1000 / 60);
                activeEffects.push(`✨ Radiant Collector (${remaining}m)`);
            }
            
            // Check Lures
            Object.keys(gameState.activeEffects.lures).forEach(biome => {
                if (gameState.activeEffects.lures[biome] > now) {
                    const remaining = Math.ceil((gameState.activeEffects.lures[biome] - now) / 1000 / 60);
                    const biomeIcons = { fire: '🔥', water: '💧', earth: '🌍', air: '💨' };
                    activeEffects.push(`${biomeIcons[biome]} Lure (${remaining}m)`);
                }
            });
            
            // Display active effects if any
            if (activeEffects.length > 0) {
                const effectsDiv = document.createElement('div');
                effectsDiv.id = 'activeEffects';
                effectsDiv.style.cssText = 'position: absolute; top: 60px; right: 10px; padding: 8px 16px; border-radius: 8px; font-size: 14px;';
                effectsDiv.textContent = activeEffects.join(' | ');
                header.appendChild(effectsDiv);
            }
        }
        
        function updateMiniMap(playerX, playerY) {
            const miniMapDot = document.getElementById('miniMapPlayerDot');
            if (!miniMapDot) return;
            
            // Scale player position to mini-map size (180x80)
            const mapWidth = 180;
            const mapHeight = 80;
            const scaleX = mapWidth / window.innerWidth;
            const scaleY = mapHeight / (window.innerHeight - 200); // Account for UI
            
            miniMapDot.style.left = (playerX * scaleX) + 'px';
            miniMapDot.style.top = (playerY * scaleY) + 'px';
        }
        
        function updateObjectives() {
            const objectivesList = document.getElementById('objectivesList');
            if (!objectivesList) return;
            
            const objectives = [];
            
            // Add current objectives based on game state
            if (gameState.kinDex.size < 20) {
                objectives.push({
                    icon: '📦',
                    text: `Catch ${20 - gameState.kinDex.size} more unique Kin`,
                    completed: false
                });
            }
            
            // Check for uncaught Kin in current biome
            if (gameState.currentBiome) {
                const biomeKin = [];
                Object.keys(kinDatabase[gameState.currentBiome]).forEach(rarity => {
                    kinDatabase[gameState.currentBiome][rarity].forEach(kin => {
                        if (!gameState.kinDex.has(kin.id)) {
                            biomeKin.push(kin);
                        }
                    });
                });
                
                if (biomeKin.length > 0) {
                    objectives.push({
                        icon: '🎯',
                        text: `${biomeKin.length} uncaught Kin in this biome`,
                        completed: false
                    });
                }
            }
            
            // Check for protectors
            if (gameState.currentBiome) {
                const undefeatedProtectors = biomeProtectors[gameState.currentBiome].filter(
                    p => !gameState.protectorsDefeated[gameState.currentBiome].includes(p.id)
                );
                
                if (undefeatedProtectors.length > 0) {
                    objectives.push({
                        icon: '⚔️',
                        text: `${undefeatedProtectors.length} Protectors to defeat`,
                        completed: false
                    });
                }
            }
            
            // Add gold objective
            if (gameState.gold < 500) {
                objectives.push({
                    icon: '💰',
                    text: `Earn ${500 - gameState.gold} more gold`,
                    completed: false
                });
            }
            
            // Display objectives
            objectivesList.innerHTML = objectives.map(obj => `
                <div class="objective ${obj.completed ? 'completed' : ''}">
                    <span class="objectiveIcon">${obj.icon}</span>
                    <span>${obj.text}</span>
                </div>
            `).join('');
            
            // If no objectives, show message
            if (objectives.length === 0) {
                objectivesList.innerHTML = `
                    <div class="objective">
                        <span class="objectiveIcon">✨</span>
                        <span>Hunt for Radiant Kin!</span>
                    </div>
                `;
            }
        }

        function addToLog(message) {
            const log = document.getElementById('activityLog');
            const entry = document.createElement('div');
            entry.className = 'logEntry';
            entry.textContent = message;
            log.insertBefore(entry, log.firstChild);
            
            // Keep only last 10 entries
            while (log.children.length > 10) {
                log.removeChild(log.lastChild);
            }
        }

        // Biome System
        let selectedBiome = null;
        let tempTeam = [];
        
        function selectBiomeForExploration(biome) {
            if (gameState.biomeBans[biome] > Date.now()) {
                showNotification('You are banned from this biome!');
                return;
            }
            
            selectedBiome = biome;
            tempTeam = [...gameState.team];
            
            // Show team selection
            document.getElementById('biomeSelection').style.display = 'none';
            document.getElementById('teamSelection').style.display = 'block';
            
            updateTeamSelectionDisplay();
        }
        
        function updateTeamSelectionDisplay() {
            // Show selected team slots
            const selectedDisplay = document.getElementById('selectedTeamDisplay');
            selectedDisplay.innerHTML = '';
            
            const elements = ['fire', 'water', 'earth', 'air'];
            const icons = { fire: '🔥', water: '💧', earth: '🌍', air: '💨' };
            
            elements.forEach(element => {
                const slot = document.createElement('div');
                slot.className = 'teamSlotSelect';
                
                const kin = tempTeam.find(k => k.element === element);
                if (kin) {
                    slot.classList.add('filled');
                    slot.innerHTML = `
                        <div style="font-size: 40px;">${getKinVisual(kin, 120)}</div>
                        <div style="font-size: 12px;">${kin.name}</div>
                        <div style="font-size: 10px;">Lv.${kin.level || 1}</div>
                    `;
                    slot.onclick = () => removeFromTempTeam(kin);
                } else {
                    slot.innerHTML = `
                        <div style="font-size: 40px;">${icons[element]}</div>
                        <div style="font-size: 12px;">Empty</div>
                    `;
                }
                
                selectedDisplay.appendChild(slot);
            });
            
            // Show available Kin
            const availableList = document.getElementById('availableKinList');
            availableList.innerHTML = '';
            
            const filter = document.getElementById('filterElement')?.value || 'all';
const sort = document.getElementById('sortOption')?.value || 'overall';

let availableKin = gameState.kinBank.filter(k => !tempTeam.includes(k));

if (filter !== 'all') {
    availableKin = availableKin.filter(k => k.element === filter);
}

availableKin.sort((a, b) => {
    if (sort === 'level') return (b.level || 1) - (a.level || 1);
    if (sort === 'name') return a.name.localeCompare(b.name);
    if (sort === 'rarity') {
        const order = { common: 0, uncommon: 1, rare: 2, epic: 3 };
        return order[b.rarity] - order[a.rarity];
    }
    // Default: overall stat %
    return getOverallStatPercent(b) - getOverallStatPercent(a);
});
            
            if (availableKin.length === 0) {
                availableList.innerHTML = '<div style="text-align: center; color: #888;">No Kin available! Catch some first!</div>';
            } else {
                const grid = document.createElement('div');
                grid.className = 'kinGrid';
                
                availableKin.forEach(kin => {
                    const card = createKinCard(kin, true);
                    card.onclick = () => addToTempTeam(kin);
                    grid.appendChild(card);
                });
                
                availableList.appendChild(grid);
            }
        }
        
        function createKinCard(kin, forSelection = false) {
            const card = document.createElement('div');
            card.className = 'kinCard';
            card.style.position = 'relative';
            if (kin.isRadiant) card.classList.add('radiant');
            
            const elementIcons = { fire: '🔥', water: '💧', earth: '🌍', air: '💨' };
            const attackNames = ['Basic', 'Strong', 'Power'];
            const attackPower = kin.attack ? kin.attack.power : 20;
            const attackIndex = attackPower === 10 ? 0 : attackPower === 20 ? 1 : 2;
            
            // Calculate XP progress
            const xpProgress = ((kin.exp || 0) / getExpNeeded(kin.level || 1)) * 100;
            
            // Get stat ranges and calculate percentages
            const ranges = {
                common: { hp: [120, 200], attack: [15, 29], speed: [12, 26], crit: [5, 10] },
                uncommon: { hp: [140, 230], attack: [18, 32], speed: [15, 29], crit: [6, 12] },
                rare: { hp: [160, 260], attack: [21, 35], speed: [18, 32], crit: [7, 14] },
                epic: { hp: [180, 290], attack: [24, 38], speed: [21, 35], crit: [8, 15] }
            };
            
            const range = ranges[kin.rarity];
            const hpPercent = Math.round((kin.stats.hp - range.hp[0]) / (range.hp[1] - range.hp[0]) * 100);
            const atkPercent = Math.round((kin.stats.attack - range.attack[0]) / (range.attack[1] - range.attack[0]) * 100);
            const spdPercent = Math.round((kin.stats.speed - range.speed[0]) / (range.speed[1] - range.speed[0]) * 100);
            const critPercent = Math.round(((kin.stats.crit || 10) - range.crit[0]) / (range.crit[1] - range.crit[0]) * 100);
            
            card.innerHTML = `
                <div style="position: absolute; top: 5px; right: 5px; font-size: 20px; opacity: 0.8;">
                    ${elementIcons[kin.element]}
                </div>
                <div class="kinCardHeader">
                    <div>
                        <span style="font-size: 24px;">${getKinVisual(kin, 120)}</span>
                        <span>${kin.name}</span>
                    </div>
                    <div style="margin-top: 20px;">
                        <div>Lv.${kin.level || 1}</div>
                        <div class="expBar">
                            <div class="expFill" style="width: ${xpProgress}%"></div>
                        </div>
                    </div>
                </div>
                <div class="kinCardStats">
                    <div class="rarity-${kin.rarity}">${kin.rarity.charAt(0).toUpperCase() + kin.rarity.slice(1)}${kin.isRadiant ? ' ✨' : ''}</div>
                    <div>HP: ${kin.stats.hp} (${hpPercent}%) | ATK: ${kin.stats.attack} (${atkPercent}%)</div>
                    <div>SPD: ${kin.stats.speed} (${spdPercent}%) | CRIT: ${kin.stats.crit || 10}% (${critPercent}%)</div>
                </div>
                <div class="kinAttacks">
                    <div class="attackOption ${attackIndex === 0 ? 'selected' : ''}">○ ${attackNames[0]} Attack - 10 Power (90%)</div>
                    <div class="attackOption ${attackIndex === 1 ? 'selected' : ''}">○ ${attackNames[1]} Attack - 20 Power (100%)</div>
                    <div class="attackOption ${attackIndex === 2 ? 'selected' : ''}">○ ${attackNames[2]} Attack - 30 Power (110%)</div>
                </div>
            `;
            
            return card;
        }
        
        function addToTempTeam(kin) {
            // Check if element already in team
            if (tempTeam.some(k => k.element === kin.element)) {
                showNotification('You already have a ' + kin.element + ' type!');
                return;
            }
            
            if (tempTeam.length >= 4) {
                showNotification('Team is full!');
                return;
            }
            
            tempTeam.push(kin);
            updateTeamSelectionDisplay();
        }
        
        function removeFromTempTeam(kin) {
            tempTeam = tempTeam.filter(k => k !== kin);
            updateTeamSelectionDisplay();
        }
        
        function confirmTeamAndExplore() {
            if (tempTeam.length === 0) {
                showNotification('You need at least one Kin!');
                return;
            }
            
            gameState.team = [...tempTeam];
    updateTeamDisplay();  // Ensure UI updates after team selection
            document.getElementById('teamSelection').style.display = 'none';
            enterBiome(selectedBiome);
        }
        
        function cancelTeamSelection() {
            document.getElementById('teamSelection').style.display = 'none';
            document.getElementById('biomeSelection').style.display = 'grid';
            selectedBiome = null;
            tempTeam = [];
        }
        
        function updateBiomeTimers() {
            const now = Date.now();
            Object.keys(gameState.biomeBans).forEach(biome => {
                const card = document.querySelector(`[data-biome="${biome}"]`);
                const timer = card.querySelector('.biomeTimer');
                
                if (gameState.biomeBans[biome] > now) {
                    const remaining = Math.ceil((gameState.biomeBans[biome] - now) / 1000 / 60);
                    timer.textContent = `Banned: ${remaining} minutes`;
                    card.classList.add('disabled');
                } else {
                    timer.textContent = '';
                    card.classList.remove('disabled');
                }
            });
        }

        function enterBiome(biome) {
            if (gameState.biomeBans[biome] > Date.now()) {
                showNotification('You are banned from this biome!');
                return;
            }
            
            gameState.currentBiome = biome;
            gameState.exploring = true;
            
            // Set next encounter times
            const now = Date.now();
            gameState.nextEncounterTime = now + randomBetween(20, 40) * 1000;
            gameState.nextSpecialTime = now + randomBetween(5, 8) * 60 * 1000;
            gameState.nextBoxTime = now + randomBetween(4, 6) * 60 * 1000;
            
            // Show exploration area
            document.getElementById('biomeSelection').style.display = 'none';
            document.getElementById('explorationArea').style.display = 'block';
            
            // Set biome background and create scenery
            createBiomeScenery(biome);
            
            // Start exploration
            addToLog(`Entered ${getBiomeName(biome)}`);
            startExploration();
            
            // Update biome info panel
            updateBiomeInfo();
        }
        
        function createBiomeScenery(biome) {
            const biomeBackground = document.getElementById('biomeBackground');
            biomeBackground.innerHTML = ''; // Clear previous scenery
            
            if (biome === 'fire') {
                // Fire biome - volcanic ground with lava pools
                biomeBackground.style.background = '#2a1a1a';
                
                // Add ground texture
                const groundTexture = document.createElement('div');
                groundTexture.className = 'biomeElement';
                groundTexture.style.cssText = `
                    width: 100%;
                    height: 100%;
                    background-image: 
                        radial-gradient(circle at 20% 30%, rgba(139, 0, 0, 0.3) 0%, transparent 30%),
                        radial-gradient(circle at 70% 60%, rgba(178, 34, 34, 0.3) 0%, transparent 40%),
                        radial-gradient(circle at 40% 80%, rgba(139, 0, 0, 0.3) 0%, transparent 35%);
                    position: absolute;
                    top: 0;
                    left: 0;
                `;
                biomeBackground.appendChild(groundTexture);
                
                // Add lava pools
                const lavaPools = [
                    { x: 15, y: 20, width: 120, height: 80 },
                    { x: 60, y: 35, width: 150, height: 100 },
                    { x: 30, y: 70, width: 100, height: 90 },
                    { x: 75, y: 15, width: 110, height: 70 },
                    { x: 45, y: 55, width: 130, height: 85 },
                    { x: 5, y: 60, width: 90, height: 80 },
                    { x: 85, y: 65, width: 100, height: 70 }
                ];
                
                lavaPools.forEach(pool => {
                    const lavaPool = document.createElement('div');
                    lavaPool.className = 'biomeElement obstacle';
                    lavaPool.style.cssText = `
                        position: absolute;
                        left: ${pool.x}%;
                        top: ${pool.y}%;
                        width: ${pool.width}px;
                        height: ${pool.height}px;
                        background: radial-gradient(ellipse at center, #ff4500, #8B0000, #4a0000);
                        border-radius: 50%;
                        box-shadow: 
                            0 0 20px #ff4500,
                            inset 0 0 20px rgba(255, 69, 0, 0.5);
                        z-index: 2;
                    `;
                    lavaPool.dataset.obstacle = 'true';
                    biomeBackground.appendChild(lavaPool);
                    
                    // Add glow effect around lava
                    const glow = document.createElement('div');
                    glow.className = 'biomeElement lavaGlow';
                    glow.style.cssText = `
                        position: absolute;
                        left: ${pool.x - 1}%;
                        top: ${pool.y - 1}%;
                        width: ${pool.width + 20}px;
                        height: ${pool.height + 20}px;
                        background: radial-gradient(ellipse at center, rgba(255, 69, 0, 0.4), transparent);
                        border-radius: 50%;
                        filter: blur(15px);
                        z-index: 1;
                    `;
                    biomeBackground.appendChild(glow);
                });
                
                // Add volcanic rocks
                for (let i = 0; i < 8; i++) {
                    const rock = document.createElement('div');
                    rock.className = 'biomeElement obstacle';
                    const size = Math.random() * 30 + 20;
                    rock.style.cssText = `
                        position: absolute;
                        left: ${Math.random() * 90 + 5}%;
                        top: ${Math.random() * 85 + 5}%;
                        width: ${size}px;
                        height: ${size}px;
                        background: radial-gradient(circle, #3a3a3a, #1a1a1a);
                        border-radius: 40%;
                        box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
                        z-index: 3;
                    `;
                    rock.dataset.obstacle = 'true';
                    biomeBackground.appendChild(rock);
                }
                
            } else if (biome === 'water') {
                // Water biome - swampy ground with ponds
                biomeBackground.style.background = '#1a2a2a';
                
                // Add ground texture
                const groundTexture = document.createElement('div');
                groundTexture.className = 'biomeElement';
                groundTexture.style.cssText = `
                    width: 100%;
                    height: 100%;
                    background-image: 
                        radial-gradient(circle at 30% 20%, rgba(0, 51, 102, 0.2) 0%, transparent 40%),
                        radial-gradient(circle at 60% 70%, rgba(0, 77, 153, 0.2) 0%, transparent 35%),
                        radial-gradient(circle at 80% 40%, rgba(0, 51, 102, 0.2) 0%, transparent 30%);
                    position: absolute;
                    top: 0;
                    left: 0;
                `;
                biomeBackground.appendChild(groundTexture);
                
                // Add water ponds
                const ponds = [
                    { x: 10, y: 25, width: 140, height: 110 },
                    { x: 55, y: 40, width: 180, height: 120 },
                    { x: 25, y: 65, width: 120, height: 100 },
                    { x: 70, y: 20, width: 150, height: 90 },
                    { x: 40, y: 45, width: 100, height: 80 },
                    { x: 80, y: 70, width: 110, height: 85 }
                ];
                
                ponds.forEach(pond => {
                    const waterPond = document.createElement('div');
                    waterPond.className = 'biomeElement obstacle';
                    waterPond.style.cssText = `
                        position: absolute;
                        left: ${pond.x}%;
                        top: ${pond.y}%;
                        width: ${pond.width}px;
                        height: ${pond.height}px;
                        background: radial-gradient(ellipse at center, #004080, #003366, #001a33);
                        border-radius: 45%;
                        box-shadow: 
                            inset 0 0 20px rgba(0, 100, 200, 0.5),
                            0 0 10px rgba(0, 100, 200, 0.3);
                        z-index: 2;
                    `;
                    waterPond.dataset.obstacle = 'true';
                    biomeBackground.appendChild(waterPond);
                });
                
                // Add swamp vegetation
                for (let i = 0; i < 15; i++) {
                    const plant = document.createElement('div');
                    plant.className = 'biomeElement';
                    plant.style.cssText = `
                        position: absolute;
                        left: ${Math.random() * 95}%;
                        top: ${Math.random() * 95}%;
                        width: 30px;
                        height: 30px;
                        background: radial-gradient(circle, #2d5a2d, #1a3a1a);
                        border-radius: 50%;
                        opacity: 0.7;
                        z-index: 1;
                    `;
                    biomeBackground.appendChild(plant);
                }
                
                // Add lily pads
                for (let i = 0; i < 10; i++) {
                    const lilypad = document.createElement('div');
                    lilypad.className = 'biomeElement';
                    lilypad.style.cssText = `
                        position: absolute;
                        left: ${Math.random() * 90 + 5}%;
                        top: ${Math.random() * 90 + 5}%;
                        width: 25px;
                        height: 25px;
                        background: radial-gradient(circle, #4d7c4d, #2d5a2d);
                        border-radius: 50%;
                        z-index: 3;
                    `;
                    biomeBackground.appendChild(lilypad);
                }
                
            } else if (biome === 'earth') {
                // Earth biome - grassy terrain with rocks and boulders
                biomeBackground.style.background = '#2a3a2a';
                
                // Add grass texture
                const groundTexture = document.createElement('div');
                groundTexture.className = 'biomeElement';
                groundTexture.style.cssText = `
                    width: 100%;
                    height: 100%;
                    background-image: 
                        radial-gradient(circle at 25% 25%, rgba(34, 139, 34, 0.2) 0%, transparent 30%),
                        radial-gradient(circle at 75% 50%, rgba(46, 125, 50, 0.2) 0%, transparent 35%),
                        radial-gradient(circle at 50% 80%, rgba(34, 139, 34, 0.2) 0%, transparent 40%);
                    position: absolute;
                    top: 0;
                    left: 0;
                `;
                biomeBackground.appendChild(groundTexture);
                
                // Add large boulders
                const boulders = [
                    { x: 20, y: 30, width: 80, height: 70 },
                    { x: 65, y: 45, width: 100, height: 85 },
                    { x: 35, y: 70, width: 90, height: 75 },
                    { x: 75, y: 25, width: 70, height: 65 },
                    { x: 10, y: 55, width: 85, height: 80 },
                    { x: 50, y: 15, width: 75, height: 70 },
                    { x: 85, y: 60, width: 65, height: 60 }
                ];
                
                boulders.forEach(boulder => {
                    const rock = document.createElement('div');
                    rock.className = 'biomeElement obstacle';
                    rock.style.cssText = `
                        position: absolute;
                        left: ${boulder.x}%;
                        top: ${boulder.y}%;
                        width: ${boulder.width}px;
                        height: ${boulder.height}px;
                        background: radial-gradient(ellipse at 30% 30%, #8B7355, #654321, #4a3a2a);
                        border-radius: 40%;
                        box-shadow: 
                            3px 3px 8px rgba(0,0,0,0.5),
                            inset -2px -2px 5px rgba(0,0,0,0.3);
                        z-index: 3;
                    `;
                    rock.dataset.obstacle = 'true';
                    biomeBackground.appendChild(rock);
                });
                
                // Add smaller rocks
                for (let i = 0; i < 12; i++) {
                    const smallRock = document.createElement('div');
                    smallRock.className = 'biomeElement obstacle';
                    const size = Math.random() * 25 + 15;
                    smallRock.style.cssText = `
                        position: absolute;
                        left: ${Math.random() * 90 + 5}%;
                        top: ${Math.random() * 90 + 5}%;
                        width: ${size}px;
                        height: ${size}px;
                        background: radial-gradient(circle, #6B5D54, #4a3a2a);
                        border-radius: 45%;
                        box-shadow: 2px 2px 4px rgba(0,0,0,0.4);
                        z-index: 2;
                    `;
                    smallRock.dataset.obstacle = 'true';
                    biomeBackground.appendChild(smallRock);
                }
                
                // Add grass patches
                for (let i = 0; i < 20; i++) {
                    const grass = document.createElement('div');
                    grass.className = 'biomeElement';
                    grass.style.cssText = `
                        position: absolute;
                        left: ${Math.random() * 95}%;
                        top: ${Math.random() * 95}%;
                        width: 40px;
                        height: 20px;
                        background: radial-gradient(ellipse, #4a7c59, #2d5a3d);
                        border-radius: 50%;
                        opacity: 0.6;
                        z-index: 1;
                    `;
                    biomeBackground.appendChild(grass);
                }
                
            } else if (biome === 'air') {
                // Air biome - cloudy/misty ground with wind patterns
                biomeBackground.style.background = '#e6f2ff';
                
                // Add cloud shadows on ground
                const groundTexture = document.createElement('div');
                groundTexture.className = 'biomeElement';
                groundTexture.style.cssText = `
                    width: 100%;
                    height: 100%;
                    background-image: 
                        radial-gradient(ellipse at 20% 30%, rgba(135, 206, 235, 0.2) 0%, transparent 40%),
                        radial-gradient(ellipse at 70% 50%, rgba(135, 206, 235, 0.2) 0%, transparent 35%),
                        radial-gradient(ellipse at 40% 80%, rgba(135, 206, 235, 0.2) 0%, transparent 45%);
                    position: absolute;
                    top: 0;
                    left: 0;
                `;
                biomeBackground.appendChild(groundTexture);
                
                // Add cloud formations on ground (fog patches)
                const clouds = [
                    { x: 15, y: 20, width: 150, height: 100 },
                    { x: 60, y: 35, width: 180, height: 110 },
                    { x: 30, y: 65, width: 140, height: 90 },
                    { x: 75, y: 15, width: 120, height: 80 },
                    { x: 45, y: 50, width: 160, height: 95 },
                    { x: 5, y: 70, width: 130, height: 85 }
                ];
                
                clouds.forEach(cloud => {
                    const cloudPatch = document.createElement('div');
                    cloudPatch.className = 'biomeElement';
                    cloudPatch.style.cssText = `
                        position: absolute;
                        left: ${cloud.x}%;
                        top: ${cloud.y}%;
                        width: ${cloud.width}px;
                        height: ${cloud.height}px;
                        background: radial-gradient(ellipse at center, rgba(255, 255, 255, 0.6), rgba(255, 255, 255, 0.2), transparent);
                        border-radius: 50%;
                        filter: blur(20px);
                        opacity: 0.7;
                        z-index: 2;
                    `;
                    biomeBackground.appendChild(cloudPatch);
                });
                
                // Add wind swirl marks on ground
                for (let i = 0; i < 8; i++) {
                    const windMark = document.createElement('div');
                    windMark.className = 'biomeElement windSwirl';
                    windMark.style.cssText = `
                        position: absolute;
                        left: ${Math.random() * 85 + 5}%;
                        top: ${Math.random() * 85 + 5}%;
                        width: 60px;
                        height: 60px;
                        border: 2px solid rgba(135, 206, 235, 0.3);
                        border-radius: 50%;
                        border-style: dashed;
                        opacity: 0.5;
                        z-index: 1;
                    `;
                    biomeBackground.appendChild(windMark);
                }
                
                // Add small whirlwind spots
                for (let i = 0; i < 10; i++) {
                    const whirl = document.createElement('div');
                    whirl.className = 'biomeElement';
                    whirl.style.cssText = `
                        position: absolute;
                        left: ${Math.random() * 90 + 5}%;
                        top: ${Math.random() * 90 + 5}%;
                        width: 30px;
                        height: 30px;
                        background: radial-gradient(circle, rgba(135, 206, 235, 0.4), transparent);
                        border-radius: 50%;
                        z-index: 1;
                    `;
                    biomeBackground.appendChild(whirl);
                }
            }
        }

        function leaveBiome() {
            gameState.exploring = false;
            gameState.currentBiome = null;
            
            document.getElementById('explorationArea').style.display = 'none';
            
            document.getElementById('biomeSelection').style.display = 'grid';
        }

        function getBiomeName(biome) {
            const names = {
                fire: 'The Ashen Peaks',
                water: 'The Sunken Grotto',
                earth: 'The Tectonic Scar',
                air: 'The Howling Spires'
            };
            return names[biome];
        }

        // Exploration System
        let playerMovement = null;
        let obstacles = [];
        
        function startExploration() {
            const player = document.getElementById('player');
            let playerX = 50;
            let playerY = 150;
            let targetX = playerX;
            let targetY = playerY;
            let walking = false;
            
            // Get all obstacles in the current biome
            obstacles = Array.from(document.querySelectorAll('.obstacle')).map(obstacle => {
                const rect = obstacle.getBoundingClientRect();
                const explorationArea = document.getElementById('explorationArea').getBoundingClientRect();
                return {
                    x: rect.left - explorationArea.left,
                    y: rect.top - explorationArea.top,
                    width: rect.width,
                    height: rect.height
                };
            });
            
            // Set initial position
            player.style.left = playerX + 'px';
            player.style.top = playerY + 'px';
            
            function pickNewTarget() {
                if (!gameState.exploring || gameState.encounterActive) return;
                
                // Pick a random target position
                let attempts = 0;
                let validTarget = false;
                let newTargetX, newTargetY;
                
                while (!validTarget && attempts < 50) {
                    newTargetX = randomBetween(50, window.innerWidth - 100);
                    newTargetY = randomBetween(100, window.innerHeight - 200);
                    
                    // Check if target is not inside an obstacle
                    validTarget = !isPointInObstacle(newTargetX, newTargetY);
                    attempts++;
                }
                
                if (validTarget) {
                    targetX = newTargetX;
                    targetY = newTargetY;
                    walking = true;
                    player.classList.remove('player-idle');
                } else {
                    // If no valid target found, try again later
                    setTimeout(pickNewTarget, 1000);
                }
            }
            
            function isPointInObstacle(x, y, playerWidth = 20, playerHeight = 30) {
                for (const obstacle of obstacles) {
                    if (x < obstacle.x + obstacle.width &&
                        x + playerWidth > obstacle.x &&
                        y < obstacle.y + obstacle.height &&
                        y + playerHeight > obstacle.y) {
                        return true;
                    }
                }
                return false;
            }
            
            function getValidPosition(fromX, fromY, toX, toY, playerWidth = 20, playerHeight = 30) {
                // Check if the destination would collide with an obstacle
                if (!isPointInObstacle(toX, toY, playerWidth, playerHeight)) {
                    return { x: toX, y: toY };
                }
                
                // If collision detected, try to find the closest valid position
                const angle = Math.atan2(toY - fromY, toX - fromX);
                const distance = Math.sqrt((toX - fromX) ** 2 + (toY - fromY) ** 2);
                
                // Binary search for the furthest valid position
                let low = 0;
                let high = distance;
                let bestDistance = 0;
                
                while (high - low > 1) {
                    const mid = (low + high) / 2;
                    const testX = fromX + Math.cos(angle) * mid;
                    const testY = fromY + Math.sin(angle) * mid;
                    
                    if (!isPointInObstacle(testX, testY, playerWidth, playerHeight)) {
                        bestDistance = mid;
                        low = mid;
                    } else {
                        high = mid;
                    }
                }
                
                return {
                    x: fromX + Math.cos(angle) * bestDistance,
                    y: fromY + Math.sin(angle) * bestDistance
                };
            }
            
            function movePlayer() {
                if (!gameState.exploring) return;
                
                if (walking && !gameState.encounterActive) {
                    // Calculate direction to target
                    const dx = targetX - playerX;
                    const dy = targetY - playerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 5) {
                        // Move towards target at constant speed
                        const speed = 0.2; // pixels per frame
                        const moveX = (dx / distance) * speed;
                        const moveY = (dy / distance) * speed;
                        
                        // Check collision and get valid position
                        const newPos = getValidPosition(playerX, playerY, playerX + moveX, playerY + moveY);
                        
                        // If we can't move at all, pick a new target
                        if (Math.abs(newPos.x - playerX) < 0.01 && Math.abs(newPos.y - playerY) < 0.01) {
                            walking = false;
                            player.classList.add('player-idle');
                            setTimeout(pickNewTarget, 500);
                        } else {
                            playerX = newPos.x;
                            playerY = newPos.y;
                            
                            player.style.left = playerX + 'px';
                            player.style.top = playerY + 'px';
                            
                            // Flip character based on direction
                            if (dx < 0) {
                                player.style.transform = 'scaleX(-1)';
                            } else {
                                player.style.transform = 'scaleX(1)';
                            }
                        }
                    } else {
                        // Reached target, wait a bit then pick new target
                        walking = false;
                        player.classList.add('player-idle');
                        setTimeout(pickNewTarget, randomBetween(1000, 3000));
                    }
                } else if (!gameState.encounterActive && !walking) {
                    // Resume walking after encounter
                    setTimeout(pickNewTarget, 1000);
                }
                
                checkEncounters();
                
            }
            
            // Store movement function globally
            playerMovement = {
                resume: () => {
                    if (!walking) {
                        pickNewTarget();
                    }
                }
            };
            
            // Start walking
            pickNewTarget();
    // Hybrid background-safe system
    if (window.explorationInterval) 
    window.explorationInterval = setInterval(() => {
        movePlayer();
    }, 100); // ~10 FPS

            movePlayer();
        }

        function checkEncounters() {
            // Don't check for any encounters if one is already active
            if (gameState.encounterActive) return;
            
            const now = Date.now();
            
            // Regular Kin encounters
            if (now >= gameState.nextEncounterTime) {
                encounterKin();
                // Check if lure is active for faster encounters
                const lureActive = gameState.activeEffects.lures[gameState.currentBiome] > now;
                const minTime = lureActive ? 10 : 20;
                const maxTime = lureActive ? 20 : 40;
                gameState.nextEncounterTime = now + randomBetween(minTime, maxTime) * 1000;
                return; // Exit after triggering one encounter
            }
            
            // Special encounters (Police/Trader)
            if (now >= gameState.nextSpecialTime) {
                if (Math.random() < 0.3) {
                    encounterPolice();
                } else {
                    encounterTrader();
                }
                gameState.nextSpecialTime = now + randomBetween(5, 8) * 60 * 1000;
                return; // Exit after triggering one encounter
            }
            
            // KinBox encounters
            if (now >= gameState.nextBoxTime) {
                findKinBox();
                gameState.nextBoxTime = now + randomBetween(4, 6) * 60 * 1000;
                return; // Exit after triggering one encounter
            }
        }

        // Encounter System
        function getRandomKin(biome) {
            const roll = Math.random() * 100;
            let rarity;
            
            if (roll < 75) rarity = 'common';
            else if (roll < 90) rarity = 'uncommon';
            else if (roll < 99) rarity = 'rare';
            else rarity = 'epic';
            
            const kinList = kinDatabase[biome][rarity];
            const kin = kinList[Math.floor(Math.random() * kinList.length)];
            
            // Check for Radiant with collector bonus
            const radiantBonus = gameState.activeEffects.radiantCollector > Date.now() ? 2 : 1;
            const isRadiant = Math.random() < (0.0005 * radiantBonus); // 0.05% or 0.1% with collector
            
            return {
                ...kin,
                rarity,
                isRadiant,
                stats: generateStats(rarity, isRadiant),
                element: biome
            };
        }

        function generateStats(rarity, isRadiant) {
            const ranges = {
                common: { hp: [120, 200], attack: [15, 29], speed: [12, 26], crit: [5, 10] },
                uncommon: { hp: [140, 230], attack: [18, 32], speed: [15, 29], crit: [6, 12] },
                rare: { hp: [160, 260], attack: [21, 35], speed: [18, 32], crit: [7, 14] },
                epic: { hp: [180, 290], attack: [24, 38], speed: [21, 35], crit: [8, 15] }
            };
            
            const range = ranges[rarity];
            
            if (isRadiant) {
                return {
                    hp: range.hp[1],
                    attack: range.attack[1],
                    speed: range.speed[1],
                    crit: range.crit[1]
                };
            } else {
                return {
                    hp: randomBetween(range.hp[0], range.hp[1]),
                    attack: randomBetween(range.attack[0], range.attack[1]),
                    speed: randomBetween(range.speed[0], range.speed[1]),
                    crit: randomBetween(range.crit[0], range.crit[1])
                };
            }
        }

        function encounterKin() {
            gameState.encounterActive = true;
            const kin = getRandomKin(gameState.currentBiome);
            
            // Track encounter statistics
            gameState.stats.totalKinEncountered++;
            if (kin.isRadiant) {
                gameState.stats.totalRadiantEncountered++;
            }
            
            // Store the current encounter for details view
            window.currentEncounterKin = kin;
            
            // Calculate overall stats percentage
            const ranges = {
                common: { hp: [120, 200], attack: [15, 29], speed: [12, 26], crit: [5, 10] },
                uncommon: { hp: [140, 230], attack: [18, 32], speed: [15, 29], crit: [6, 12] },
                rare: { hp: [160, 260], attack: [21, 35], speed: [18, 32], crit: [7, 14] },
                epic: { hp: [180, 290], attack: [24, 38], speed: [21, 35], crit: [8, 15] }
            };
            
            const range = ranges[kin.rarity];
            const hpPercent = Math.round((kin.stats.hp - range.hp[0]) / (range.hp[1] - range.hp[0]) * 100);
            const atkPercent = Math.round((kin.stats.attack - range.attack[0]) / (range.attack[1] - range.attack[0]) * 100);
            const spdPercent = Math.round((kin.stats.speed - range.speed[0]) / (range.speed[1] - range.speed[0]) * 100);
            const critPercent = Math.round((kin.stats.crit - range.crit[0]) / (range.crit[1] - range.crit[0]) * 100);
            const overallPercent = Math.round((hpPercent + atkPercent + spdPercent + critPercent) / 4);
            
            const modal = document.getElementById('encounterModal');
            const content = document.getElementById('encounterContent');
            
            content.innerHTML = `
                <h2>${kin.isRadiant ? 'Radiant ' : ''}${kin.name} appeared!</h2>
                <div class="kinSprite ${kin.isRadiant ? 'radiant' : ''}">${getKinVisual(kin, 120)}</div>
                <div class="kinInfo">
                    <div class="rarity-${kin.rarity}">${kin.rarity.charAt(0).toUpperCase() + kin.rarity.slice(1)}</div>
                    <div style="font-size: 14px; color: #888;">HP: ${kin.stats.hp} | ATK: ${kin.stats.attack} | SPD: ${kin.stats.speed} | CRIT: ${kin.stats.crit}%</div>
                    
                    <div class="statQualityBar">
                        <div class="statQualityFill ${overallPercent >= 75 ? 'quality-excellent' : overallPercent >= 50 ? 'quality-good' : overallPercent >= 25 ? 'quality-poor' : 'quality-terrible'}" 
                             style="width: ${overallPercent}%"
                             data-percent="${overallPercent}%">
                        </div>
                    </div>
                    
                    <div style="font-size: 13px; color: #888; margin-top: 5px;">
                        ${overallPercent >= 75 ? 'Excellent stats! Worth catching!' : 
                          overallPercent >= 50 ? 'Above average stats' : 
                          overallPercent >= 25 ? 'Below average stats' : 
                          'Poor stats - consider skipping'}
                    </div>
                </div>
                
                <div class="quickCatchBar">
                    ${overallPercent >= 75 ? '<span class="quickCatchBtn recommended">⭐ Recommended</span>' : ''}
                    ${kin.isRadiant ? '<span class="quickCatchBtn recommended">✨ RADIANT - Must Catch!</span>' : ''}
                </div>
                
                <div style="margin: 10px 0;">
                    <button class="orbButton" onclick="showEncounterDetails()">View Detailed Stats</button>
                </div>
                <div id="orbSelection">
                    <button class="orbButton" onclick="attemptCatch('common', '${kin.id}', ${kin.isRadiant})">
                        Orb (60%) - ${gameState.orbs.common} left
                    </button>
                    <button class="orbButton" onclick="attemptCatch('great', '${kin.id}', ${kin.isRadiant})" ${gameState.orbs.great === 0 ? 'disabled' : ''}>
                        Great Orb (70%) - ${gameState.orbs.great} left
                    </button>
                    <button class="orbButton" onclick="flee()">Run Away</button>
                </div>
            `;
            
            modal.style.display = 'block';
            addToLog(`Found ${kin.isRadiant ? 'Radiant ' : ''}${kin.name}!`);
        }

        function showEncounterDetails() {
            const kin = window.currentEncounterKin;
            if (!kin) return;
            
            const detailsModal = document.getElementById('kinDetails');
            const content = document.getElementById('kinDetailsContent');
            
            // Get stat ranges for comparison
            const ranges = {
                common: { hp: [120, 200], attack: [15, 29], speed: [12, 26], crit: [5, 10] },
                uncommon: { hp: [140, 230], attack: [18, 32], speed: [15, 29], crit: [6, 12] },
                rare: { hp: [160, 260], attack: [21, 35], speed: [18, 32], crit: [7, 14] },
                epic: { hp: [180, 290], attack: [24, 38], speed: [21, 35], crit: [8, 15] }
            };
            
            const range = ranges[kin.rarity];
            const hpPercent = Math.round((kin.stats.hp - range.hp[0]) / (range.hp[1] - range.hp[0]) * 100);
            const atkPercent = Math.round((kin.stats.attack - range.attack[0]) / (range.attack[1] - range.attack[0]) * 100);
            const spdPercent = Math.round((kin.stats.speed - range.speed[0]) / (range.speed[1] - range.speed[0]) * 100);
            const critPercent = Math.round((kin.stats.crit - range.crit[0]) / (range.crit[1] - range.crit[0]) * 100);
            
            content.innerHTML = `
                <h2>${kin.name} Analysis</h2>
                <div style="text-align: center; margin: 20px 0;">
                    <div class="kinSprite ${kin.isRadiant ? 'radiant' : ''}">${getKinVisual(kin, 120)}</div>
                    <div class="rarity-${kin.rarity}">${kin.rarity.charAt(0).toUpperCase() + kin.rarity.slice(1)}${kin.isRadiant ? ' ✨ Radiant' : ''}</div>
                </div>
                
                <div style="margin: 20px 0;">
                    <h3>Detailed Stats</h3>
                    <div style="margin: 10px 0;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                            <span>HP: ${kin.stats.hp}</span>
                            <span>${hpPercent}%</span>
                        </div>
                        <div class="statQualityBar" style="height: 10px;">
                            <div class="statQualityFill ${hpPercent >= 75 ? 'quality-excellent' : hpPercent >= 50 ? 'quality-good' : hpPercent >= 25 ? 'quality-poor' : 'quality-terrible'}" 
                                 style="width: ${hpPercent}%"></div>
                        </div>
                    </div>
                    
                    <div style="margin: 10px 0;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                            <span>Attack: ${kin.stats.attack}</span>
                            <span>${atkPercent}%</span>
                        </div>
                        <div class="statQualityBar" style="height: 10px;">
                            <div class="statQualityFill ${atkPercent >= 75 ? 'quality-excellent' : atkPercent >= 50 ? 'quality-good' : atkPercent >= 25 ? 'quality-poor' : 'quality-terrible'}" 
                                 style="width: ${atkPercent}%"></div>
                        </div>
                    </div>
                    
                    <div style="margin: 10px 0;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                            <span>Speed: ${kin.stats.speed}</span>
                            <span>${spdPercent}%</span>
                        </div>
                        <div class="statQualityBar" style="height: 10px;">
                            <div class="statQualityFill ${spdPercent >= 75 ? 'quality-excellent' : spdPercent >= 50 ? 'quality-good' : spdPercent >= 25 ? 'quality-poor' : 'quality-terrible'}" 
                                 style="width: ${spdPercent}%"></div>
                        </div>
                    </div>
                    
                    <div style="margin: 10px 0;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                            <span>Crit Chance: ${kin.stats.crit}%</span>
                            <span>${critPercent}%</span>
                        </div>
                        <div class="statQualityBar" style="height: 10px;">
                            <div class="statQualityFill ${critPercent >= 75 ? 'quality-excellent' : critPercent >= 50 ? 'quality-good' : critPercent >= 25 ? 'quality-poor' : 'quality-terrible'}" 
                                 style="width: ${critPercent}%"></div>
                        </div>
                    </div>
                </div>
                
                <div style="margin: 20px 0;">
                    <h3>Attack Power</h3>
                    <div class="attackOption">○ Basic Attack - ? Power (?%)</div>
                    <div class="attackOption">○ Strong Attack - ? Power (?%)</div>
                    <div class="attackOption">○ Power Attack - ? Power (?%)</div>
                    <div style="font-size: 12px; color: #888; margin-top: 5px;">Attack type unknown until caught!</div>
                </div>
                
                <div style="text-align: center; margin-top: 20px;">
                    <div style="font-size: 18px; color: #4CAF50;">
                        <strong>Overall Stats: ${Math.round((hpPercent + atkPercent + spdPercent + critPercent) / 4)}%</strong>
                    </div>
                </div>
            `;
            
            detailsModal.style.display = 'block';
        }

        function attemptCatch(orbType, kinId, isRadiant) {
            const catchRates = {
                common: 0.6,
                great: 0.7,
                rare: 0.8,
                epic: 0.9,
                legendary: 0.99
            };
            
            if (gameState.orbs[orbType] <= 0) {
                showNotification('No orbs of that type!');
                return;
            }
            
            gameState.orbs[orbType]--;
            gameState.stats.orbsUsed[orbType]++;
            updateDisplay();
            
            const caught = Math.random() < catchRates[orbType];
            
            if (caught) {
                const kin = getRandomKin(gameState.currentBiome);
                kin.id = kinId;
                kin.isRadiant = isRadiant;
                kin.level = 1;
                kin.exp = 0;
                kin.attack = getRandomAttack();
                
                gameState.kinBank.push(kin);
                gameState.kinDex.add(kinId);
                gameState.totalKinCaught++;
                if (isRadiant) {
                    gameState.radiantDex.add(kinId);
                }
                
                // Give XP to same-element Kin on active team
                const catchXP = 20;
                gameState.team.forEach(teamKin => {
                    if (teamKin.element === kin.element) {
                        const oldLevel = teamKin.level || 1;
                        teamKin.exp = (teamKin.exp || 0) + catchXP;
                        
                        // Check for level up with new EXP requirements
                        while (teamKin.exp >= getExpNeeded(teamKin.level || 1)) {
                            teamKin.exp -= getExpNeeded(teamKin.level || 1);
                            teamKin.level = (teamKin.level || 1) + 1;
                            levelUpStats(teamKin);
                        }
                        
                        if (teamKin.level > oldLevel) {
                            addToLog(`${teamKin.name} gained ${catchXP} XP and leveled up to ${teamKin.level}!`);
                        } else {
                            addToLog(`${teamKin.name} gained ${catchXP} XP from catching a ${kin.element} Kin!`);
                        }
                        
                        updateTeamDisplay();
                    }
                });
                
                // Update biome info to reflect new catch
                updateBiomeInfo();
                
                showNotification('Caught successfully!');
                addToLog(`Caught ${kin.name}!`);
                
                // Auto-add to team if space available
                if (gameState.team.length < 4 && !gameState.team.some(k => k.element === gameState.currentBiome)) {
                    gameState.team.push(kin);
                    updateTeamDisplay();
                }
            } else {
                showNotification('The Kin broke free!');
                addToLog(`Failed to catch ${kinId}`);
            }
            
            closeEncounter();
        }

        function getRandomAttack() {
            const attacks = [
                { power: 10, modifier: 0.9 },
                { power: 20, modifier: 1.0 },
                { power: 30, modifier: 1.1 }
            ];
            return attacks[Math.floor(Math.random() * attacks.length)];
        }
        
        function getAttackName(attack) {
            if (!attack) return 'Unknown';
            if (attack.power === 10) return 'Basic';
            if (attack.power === 20) return 'Strong';
            if (attack.power === 30) return 'Power';
            return 'Unknown';
        }

        function flee() {
            closeEncounter();
            addToLog('Ran away from encounter');
        }

        function closeEncounter() {
            document.getElementById('encounterModal').style.display = 'none';
            gameState.encounterActive = false;
            
            // Remove battle background if it exists
            const battleBg = document.getElementById('battleBackground');
            if (battleBg) battleBg.remove();
            
            // Reset encounter timers to prevent immediate new encounters
            const now = Date.now();
            if (gameState.nextEncounterTime <= now) {
                const lureActive = gameState.activeEffects.lures[gameState.currentBiome] > now;
                const minTime = lureActive ? 10 : 20;
                const maxTime = lureActive ? 20 : 40;
                gameState.nextEncounterTime = now + randomBetween(minTime, maxTime) * 1000;
            }
            if (gameState.nextSpecialTime <= now) {
                gameState.nextSpecialTime = now + randomBetween(5, 8) * 60 * 1000;
            }
            if (gameState.nextBoxTime <= now) {
                gameState.nextBoxTime = now + randomBetween(4, 6) * 60 * 1000;
            }
            
            // Resume player movement
            if (playerMovement && playerMovement.resume) {
                playerMovement.resume();
            }
        }

        // Police Encounter System
        function encounterPolice() {
            if (gameState.team.length === 0) {
                addToLog('Police approached but you have no Kin!');
                return;
            }
            
            gameState.encounterActive = true;
            const policeTeam = generatePoliceTeam();
            
            const modal = document.getElementById('encounterModal');
            const content = document.getElementById('encounterContent');
            
            content.innerHTML = `
                <h2>Biome Police Challenge!</h2>
                <div style="color: #ff6666;">You must battle!</div>
                <div class="kinInfo">
                    <div>Police Team: ${policeTeam.length} ${gameState.currentBiome} Kin</div>
                </div>
                <button class="orbButton" onclick="startBattle(${JSON.stringify(policeTeam).replace(/"/g, '&quot;')})">
                    Begin Battle
                </button>
            `;
            
            modal.style.display = 'block';
            addToLog('Encountered Biome Police!');
        }

        function generatePoliceTeam() {
            const team = [];
            const teamSize = gameState.team.length;
            const highestLevel = Math.max(...gameState.team.map(k => k.level || 1));
            
            for (let i = 0; i < teamSize; i++) {
                const kin = getRandomKin(gameState.currentBiome);
                kin.level = Math.max(1, highestLevel - randomBetween(0, 10));
                kin.stats.hp = Math.floor(kin.stats.hp * (1 + (kin.level - 1) * 0.1));
                kin.stats.attack = Math.floor(kin.stats.attack * (1 + (kin.level - 1) * 0.1));
                kin.stats.speed = Math.floor(kin.stats.speed * (1 + (kin.level - 1) * 0.1));
                kin.currentHp = kin.stats.hp;
                kin.attack = getRandomAttack();
                team.push(kin);
            }
            
            return team;
        }

        // Battle System
        function startBattle(policeTeam) {
            const modal = document.getElementById('encounterModal');
            const content = document.getElementById('encounterContent');
            
            // Prepare battle state
            const playerTeam = gameState.team.map(k => ({
                ...k,
                currentHp: k.stats.hp,
                maxHp: k.stats.hp,
                element: k.element || gameState.currentBiome // Fix to use actual element
            }));
            
            const enemyTeam = policeTeam.map(k => ({
                ...k,
                currentHp: k.stats.hp,
                maxHp: k.stats.hp,
                element: gameState.currentBiome
            }));
            
            let battleLog = [];
            window.currentBattleLog = battleLog; // Store globally for end screen
            let playerIndex = 0;
            let enemyIndex = 0;
            
            // Auto-battle logic
            function battleTurn() {
                const allFighters = [
                    ...playerTeam.filter(k => k.currentHp > 0).map(k => ({...k, isPlayer: true})),
                    ...enemyTeam.filter(k => k.currentHp > 0).map(k => ({...k, isPlayer: false}))
                ].sort((a, b) => b.stats.speed - a.stats.speed);
                
                for (const fighter of allFighters) {
                    if (fighter.currentHp <= 0) continue;
                    
                    const targets = fighter.isPlayer ? 
                        enemyTeam.filter(k => k.currentHp > 0) : 
                        playerTeam.filter(k => k.currentHp > 0);
                    
                    if (targets.length === 0) break;
                    
                    const target = targets[0];
                    const damage = calculateDamage(fighter, target);
                    target.currentHp = Math.max(0, target.currentHp - damage);
                    
                    battleLog.push(`${fighter.name} deals ${damage} damage to ${target.name}!`);
                    
                    if (target.currentHp === 0) {
                        battleLog.push(`${target.name} fainted!`);
                    }
                }
                
                // Check battle end
                const playerAlive = playerTeam.some(k => k.currentHp > 0);
                const enemyAlive = enemyTeam.some(k => k.currentHp > 0);
                
                if (!playerAlive || !enemyAlive) {
                    endBattle(playerAlive);
                    return;
                }
                
                // Update display
                updateBattleDisplay();
                setTimeout(battleTurn, 1000);
            }
            
            function calculateDamage(attacker, defender) {
                const baseDamage = attacker.stats.attack * attacker.attack.modifier;
                const typeMultiplier = getTypeMultiplier(attacker.element, defender.element);
                
                // Check for critical hit
                const critChance = attacker.stats.crit || 10;
                const isCrit = Math.random() * 100 < critChance;
                const critMultiplier = isCrit ? 1.5 : 1.0;
                
                const totalDamage = Math.floor(baseDamage * typeMultiplier * critMultiplier);
                
                return totalDamage;
            }
            
            function getTypeMultiplier(attackType, defendType) {
                const effectiveness = {
                    fire: { earth: 1.2, water: 0.8 },
                    water: { fire: 1.2, air: 0.8 },
                    earth: { air: 1.2, fire: 0.8 },
                    air: { water: 1.2, earth: 0.8 }
                };
                
                if (effectiveness[attackType] && effectiveness[attackType][defendType]) {
                    return effectiveness[attackType][defendType];
                }
                return 1.0;
            }
            
            function updateBattleDisplay() {
                content.innerHTML = `
                    <h2>Battle in Progress!</h2>
                    <div style="display: flex; justify-content: space-between; margin: 20px 0;">
                        <div>
                            <h3>Your Team</h3>
                            ${playerTeam.map(k => `
                                <div>${k.name} - HP: ${k.currentHp}/${k.maxHp}</div>
                            `).join('')}
                        </div>
                        <div>
                            <h3>Police Team</h3>
                            ${enemyTeam.map(k => `
                                <div>${k.name} - HP: ${k.currentHp}/${k.maxHp}</div>
                            `).join('')}
                        </div>
                    </div>
                    <div style="max-height: 150px; overflow-y: auto; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px;">
                        ${battleLog.slice(-5).join('<br>')}
                    </div>
                `;
            }
            
            function endBattle(playerWon) {
                if (playerWon) {
                    const goldReward = randomBetween(25, 50);
                    gameState.gold += goldReward;
                    gameState.stats.totalGoldEarned += goldReward;
                    gameState.stats.policeBattlesWon++;
                    const expReward = 50 * enemyTeam.length;
                    
                    gameState.team.forEach(kin => {
                        kin.exp = (kin.exp || 0) + expReward;
                        // Level up check with new EXP system
                        while (kin.exp >= getExpNeeded(kin.level || 1)) {
                            kin.exp -= getExpNeeded(kin.level || 1);
                            kin.level = (kin.level || 1) + 1;
                            levelUpStats(kin);
                        }
                    });
                    
                    content.innerHTML = `
                        <h2>Victory!</h2>
                        <div class="kinInfo">
                            <div>Earned ${goldReward} gold!</div>
                            <div>All Kin gained ${expReward} EXP!</div>
                        </div>
                        <button class="orbButton" onclick="closeEncounter()">Continue</button>
                    `;
                    
                    addToLog(`Defeated Police! +${goldReward} gold`);
                } else {
                    const goldLoss = randomBetween(25, 50);
                    gameState.gold = Math.max(0, gameState.gold - goldLoss);
                    gameState.biomeBans[gameState.currentBiome] = Date.now() + 60 * 60 * 1000; // 1 hour
                    gameState.stats.policeBattlesLost++;
                    
                    content.innerHTML = `
                        <h2>Defeated!</h2>
                        <div class="kinInfo">
                            <div style="color: #ff6666;">Lost ${goldLoss} gold!</div>
                            <div style="color: #ff6666;">Banned from this biome for 1 hour!</div>
                        </div>
                        <button class="orbButton" onclick="closeEncounterAndLeave()">Leave Biome</button>
                    `;
                    
                    addToLog(`Lost to Police! -${goldLoss} gold, banned 1 hour`);
                }
                
                updateDisplay();
            }
            
            function levelUpStats(kin) {
                kin.stats.hp += 5;
                kin.stats.attack += 2;
                kin.stats.speed += 2;
                kin.stats.crit = (kin.stats.crit || 10) + 0.1;
                addToLog(`${kin.name} leveled up to ${kin.level}!`);
            }
            
            // Start the battle
            updateBattleDisplay();
            setTimeout(battleTurn, 1000);
        }

        function closeEncounterAndLeave() {
            closeEncounter();
            leaveBiome();
        }

        // Trader System
        function encounterTrader() {
            gameState.encounterActive = true;
            
            const items = generateTraderInventory();
            const modal = document.getElementById('encounterModal');
            const content = document.getElementById('encounterContent');
            
            content.innerHTML = `
                <h2>Traveling Trader</h2>
                <div class="kinInfo">
                    <div>Gold: ${gameState.gold}</div>
                </div>
                <div style="margin: 20px 0;">
                    ${items.map((item, index) => `
                        <div style="margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                            <div>${item.name}</div>
                            <div style="font-size: 14px; color: #888;">${item.description}</div>
                            <button class="orbButton" onclick="buyItem(${index})" ${gameState.gold < item.price ? 'disabled' : ''}>
                                Buy - ${item.price} Gold
                            </button>
                        </div>
                    `).join('')}
                </div>
                <button class="orbButton" onclick="closeEncounter()">No Thanks</button>
            `;
            
            modal.style.display = 'block';
            addToLog('Met a traveling trader!');
            
            // Store items temporarily
            window.traderItems = items;
        }

        function generateTraderInventory() {
            const items = [
                { name: 'Orb', price: 10, type: 'orb', quantity: 1, description: '60% catch rate' },
                { name: 'Great Orb', price: 25, type: 'great', quantity: 1, description: '70% catch rate' }
            ];
            
            // Add two random items
            const possibleItems = [
                { name: 'Rare Orb', price: 200, type: 'rare', quantity: 1, description: '80% catch rate' },
                { name: 'Epic Orb', price: 500, type: 'epic', quantity: 1, description: '90% catch rate' },
                { name: 'Legendary Orb', price: 5000, type: 'legendary', quantity: 1, description: '99% catch rate' },
                { name: 'Radiant Collector', price: 500, type: 'radiant_collector', description: 'Double Radiant chance for 30 min' },
                { name: `Lure of ${getBiomeName(gameState.currentBiome)}`, price: 500, type: 'lure', description: 'Double Kin encounters for 25 min' }
            ];
            
            for (let i = 0; i < 2; i++) {
                const item = possibleItems[Math.floor(Math.random() * possibleItems.length)];
                items.push(item);
            }
            
            return items;
        }

        function buyItem(index) {
            const item = window.traderItems[index];
            if (gameState.gold < item.price) return;
            
            gameState.gold -= item.price;
            
            if (item.type === 'orb' || item.type === 'great' || item.type === 'rare' || item.type === 'epic' || item.type === 'legendary') {
                gameState.orbs[item.type === 'orb' ? 'common' : item.type] += item.quantity;
                showNotification(`Bought ${item.name}!`);
            } else if (item.type === 'radiant_collector') {
                gameState.activeEffects.radiantCollector = Date.now() + 30 * 60 * 1000; // 30 minutes
                showNotification('Radiant Collector active for 30 minutes! Double chance for Radiant Kin!');
            } else if (item.type === 'lure') {
                gameState.activeEffects.lures[gameState.currentBiome] = Date.now() + 25 * 60 * 1000; // 25 minutes
                showNotification(`${item.name} active for 25 minutes! Kin appear twice as fast!`);
            }
            
            updateDisplay();
            // Update gold display in trader
            document.querySelector('#encounterModal .kinInfo div').textContent = `Gold: ${gameState.gold}`;
            
            // Update button states
            const buttons = document.querySelectorAll('#encounterModal .orbButton');
            window.traderItems.forEach((item, idx) => {
                if (buttons[idx] && buttons[idx].textContent.includes('Buy')) {
                    buttons[idx].disabled = gameState.gold < item.price;
                }
            });
        }

        // KinBox System
        function findKinBox() {
            gameState.encounterActive = true;
            gameState.stats.totalBoxesFound++;
            
            const boxRarity = getRandomBoxRarity();
            const modal = document.getElementById('encounterModal');
            const content = document.getElementById('encounterContent');
            
            content.innerHTML = `
                <h2>Found a KinBox!</h2>
                <div class="kinSprite">${boxRarity.icon}</div>
                <div class="kinInfo">
                    <div class="${boxRarity.class}">${boxRarity.name}</div>
                </div>
                <button class="orbButton" onclick="openKinBox('${boxRarity.type}')">
                    Open Box
                </button>
            `;
            
            modal.style.display = 'block';
            addToLog(`Found a ${boxRarity.name}!`);
        }

        function getRandomBoxRarity() {
            const roll = Math.random() * 100;
            if (roll < 70) return { type: 'common', name: 'Common Box', icon: '📦', class: 'rarity-common' };
            if (roll < 95) return { type: 'rare', name: 'Rare Box', icon: '📦', class: 'rarity-rare' };
            if (roll < 99.9) return { type: 'epic', name: 'Epic Box', icon: '📦', class: 'rarity-epic' };
            return { type: 'legendary', name: 'Legendary Box', icon: '📦', class: 'rarity-epic', style: 'color: gold;' };
        }

        function openKinBox(rarity) {
            const rewards = {
                common: [
                    { type: 'gold', amount: randomBetween(3, 25) },
                    { type: 'great_orbs', amount: randomBetween(3, 5) },
                    { type: 'orbs', amount: randomBetween(5, 10) }
                ],
                rare: [
                    { type: 'gold', amount: randomBetween(25, 100) },
                    { type: 'rare_orbs', amount: randomBetween(1, 3) }
                ],
                epic: [
                    { type: 'gold', amount: randomBetween(75, 150) },
                    { type: 'epic_orbs', amount: randomBetween(1, 2) }
                ],
                legendary: [
                    { type: 'gold', amount: 500 },
                    { type: 'radiant_collector', amount: 1 },
                    { type: 'legendary_orb', amount: 1 }
                ]
            };
            
            const possibleRewards = rewards[rarity];
            const reward = possibleRewards[Math.floor(Math.random() * possibleRewards.length)];
            
            let rewardText = '';
            switch(reward.type) {
                case 'gold':
                    gameState.gold += reward.amount;
                    gameState.stats.totalGoldEarned += reward.amount;
                    rewardText = `${reward.amount} Gold!`;
                    break;
                case 'orbs':
                    gameState.orbs.common += reward.amount;
                    rewardText = `${reward.amount} Orbs!`;
                    break;
                case 'great_orbs':
                    gameState.orbs.great += reward.amount;
                    rewardText = `${reward.amount} Great Orbs!`;
                    break;
                case 'rare_orbs':
                    gameState.orbs.rare += reward.amount;
                    rewardText = `${reward.amount} Rare Orbs!`;
                    break;
                case 'epic_orbs':
                    gameState.orbs.epic += reward.amount;
                    rewardText = `${reward.amount} Epic Orbs!`;
                    break;
                case 'legendary_orb':
                    gameState.orbs.legendary += reward.amount;
                    rewardText = `1 Legendary Orb!`;
                    break;
                default:
                    rewardText = reward.type;
            }
            
            const modal = document.getElementById('encounterModal');
            const content = document.getElementById('encounterContent');
            
            content.innerHTML = `
                <h2>Box Opened!</h2>
                <div class="kinInfo">
                    <div>Received: ${rewardText}</div>
                </div>
                <button class="orbButton" onclick="closeEncounter()">Continue</button>
            `;
            
            updateDisplay();
            addToLog(`Box contained: ${rewardText}`);
        }

        // KinBank System
        function openKinBank() {
            const modal = document.getElementById('kinBankModal');
            modal.style.display = 'block';
            
            document.getElementById('totalCaught').textContent = gameState.totalKinCaught;
            document.getElementById('radiantCount').textContent = gameState.radiantDex.size;
            
            displayKinBank('all');
        }
        
        function closeKinBank() {
            document.getElementById('kinBankModal').style.display = 'none';
        }
        
        function filterKinBank(filter) {
            // Update active button
            document.querySelectorAll('.filterButton').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            displayKinBank(filter);
        }
        
        function displayKinBank(filter) {
            const grid = document.getElementById('kinBankGrid');
            grid.innerHTML = '';
            
            let kinToShow = gameState.kinBank;
            
            if (filter !== 'all') {
                if (filter === 'radiant') {
                    kinToShow = kinToShow.filter(k => k.isRadiant);
                } else {
                    kinToShow = kinToShow.filter(k => k.element === filter);
                }
            }
            
            if (kinToShow.length === 0) {
                grid.innerHTML = '<div style="text-align: center; color: #888; grid-column: span 4; font-size: 18px; padding: 40px;">No Kin found with this filter!</div>';
                return;
            }
            
            kinToShow.forEach((kin, index) => {
                const card = document.createElement('div');
                card.className = 'kinBankCard';
                if (kin.isRadiant) card.classList.add('radiant');
                
                // Calculate overall stat percentage
                const overallPercent = getOverallStatPercent(kin);
                let statColor = '#666';
                if (overallPercent >= 75) statColor = '#4CAF50';
                else if (overallPercent >= 50) statColor = '#ff9800';
                else if (overallPercent >= 25) statColor = '#f44336';
                
                const elementIcons = { fire: '🔥', water: '💧', earth: '🌍', air: '💨' };
                const rarityColors = {
                    common: '#e0e0e0',
                    uncommon: '#4CAF50',
                    rare: '#2196F3',
                    epic: '#9C27B0'
                };
                
                // Get attack name
                const attackName = getAttackName(kin.attack);
                
                // Find the actual index in the full gameState.kinBank array
                const actualKinIndex = gameState.kinBank.findIndex(k => k === kin);
                
                card.innerHTML = `
                    <div class="kinBankCardHeader">
                        <div class="kinBankCardName">${kin.name} ${kin.isRadiant ? '✨' : ''}</div>
    <div style="position: absolute; top: 10px; left: 10px;">
        
    </div>
    <div style="position: absolute; top: 10px; left: 10px;">
<button onclick="releaseKinDirectly(${actualKinIndex})" title="Release" style="background: transparent; color: #f44336; border: none; font-size: 32px; cursor: pointer;">❌</button>
    </div>
    
                        <div class="kinBankCardLevel">Level ${kin.level || 1} • ${kin.element.charAt(0).toUpperCase() + kin.element.slice(1)}</div>
                    </div>
                    <div class="kinBankOverallStat" style="cursor: pointer;" onclick="showKinDetails(\'${kin.id}\')">${overallPercent}%</div>
                    <div class="kinBankCardBody">
                        <div class="kinBankCardIcon">${getKinVisual(kin, 120)}</div>
                        <div class="kinBankCardStats">
                            <span class="kinBankCardStat" style="color: ${rarityColors[kin.rarity]};">
                                ${kin.rarity.charAt(0).toUpperCase() + kin.rarity.slice(1)}
                            </span>
                            <span class="kinBankCardStat">HP: ${kin.stats.hp}</span>
                            <span class="kinBankCardStat">ATK: ${kin.stats.attack}</span>
                            <span class="kinBankCardStat">SPD: ${kin.stats.speed}</span>
                            <span class="kinBankCardStat">CRIT: ${kin.stats.crit || 10}%</span>
                            <span class="kinBankCardStat" style="background: rgba(76, 175, 80, 0.2);">
                                ${attackName} (${Math.round(kin.attack.modifier * 100)}%)
                            </span>
                        </div>
                        
                    </div>
                `;
                
                grid.appendChild(card);
            });
        }
        
        function releaseKinDirectly(kinIndex) {
            // Check if this is the last Kin
            if (gameState.kinBank.length <= 1) {
                showNotification('You must keep at least one Kin in your KinBank!');
                return;
            }
            
            // Check if index is valid
            if (kinIndex < 0 || kinIndex >= gameState.kinBank.length) {
                return;
            }
            
            const kin = gameState.kinBank[kinIndex];
            if (!kin) return;
            
            // Simple JavaScript confirm
            if (confirm(`Release ${kin.name}? This cannot be undone!`)) {
                // Remove from team if present
                gameState.team = gameState.team.filter(k => k !== kin);
                
                // Remove from bank
                gameState.kinBank.splice(kinIndex, 1);
                
                // Update displays
                showNotification(`Released ${kin.name}!`);
                
                // Re-display the KinBank
                displayKinBank('all');
                updateDisplay();
                updateTeamDisplay();
                
                // Update counts
                gameState.totalKinCaught = gameState.kinBank.length;
                document.getElementById('totalCaught').textContent = gameState.totalKinCaught;
                document.getElementById('radiantCount').textContent = gameState.kinBank.filter(k => k.isRadiant).length;
            }
        }
        
        function releaseKinByReference(kinUniqueId) {
            // Check if this is the last Kin
            if (gameState.kinBank.length <= 1) {
                showNotification('You must keep at least one Kin in your KinBank!');
                return;
            }
            
            const kin = window.kinRefs[kinUniqueId];
            if (!kin) return;
            
            if (confirm(`Release ${kin.name}? This cannot be undone!`)) {
                // Find the actual index of this Kin in the bank
                const kinIndex = gameState.kinBank.indexOf(kin);
                if (kinIndex === -1) return;
                
                // Remove from team if present
                gameState.team = gameState.team.filter(k => k !== kin);
                
                // Remove from bank
                gameState.kinBank.splice(kinIndex, 1);
                
                // Update displays
                showNotification(`Released ${kin.name}!`);
                
                // Re-display the KinBank with the current filter
                const activeFilter = document.querySelector('.filterButton.active');
                const currentFilter = activeFilter ? activeFilter.textContent.toLowerCase().trim() : 'all';
                
                // Map button text to filter values
                let filterValue = 'all';
                if (currentFilter.includes('fire')) filterValue = 'fire';
                else if (currentFilter.includes('water')) filterValue = 'water';
                else if (currentFilter.includes('earth')) filterValue = 'earth';
                else if (currentFilter.includes('air')) filterValue = 'air';
                else if (currentFilter.includes('radiant')) filterValue = 'radiant';
                
                displayKinBank(filterValue);
                updateDisplay();
                updateTeamDisplay();
                
                // Update total caught count
                gameState.totalKinCaught = gameState.kinBank.length;
                document.getElementById('totalCaught').textContent = gameState.totalKinCaught;
                
                // Update radiant count if needed
                const radiantCount = gameState.kinBank.filter(k => k.isRadiant).length;
                document.getElementById('radiantCount').textContent = radiantCount;
                
                // Clean up the reference
                delete window.kinRefs[kinUniqueId];
            }
        }
        
        function releaseKinByIndex(kinIndex) {
            // Check if this is the last Kin
            if (gameState.kinBank.length <= 1) {
                showNotification('You must keep at least one Kin in your KinBank!');
                return;
            }
            
            const kin = gameState.kinBank[kinIndex];
            if (!kin) return;
            
            if (confirm(`Release ${kin.name}? This cannot be undone!`)) {
                // Remove from team if present
                gameState.team = gameState.team.filter(k => k !== kin);
                
                // Remove from bank
                gameState.kinBank.splice(kinIndex, 1);
                
                // Update displays
                showNotification(`Released ${kin.name}!`);
                
                // Re-display the KinBank with the current filter
                const activeFilter = document.querySelector('.filterButton.active');
                const currentFilter = activeFilter ? activeFilter.textContent.toLowerCase().trim() : 'all';
                
                // Map button text to filter values
                let filterValue = 'all';
                if (currentFilter.includes('fire')) filterValue = 'fire';
                else if (currentFilter.includes('water')) filterValue = 'water';
                else if (currentFilter.includes('earth')) filterValue = 'earth';
                else if (currentFilter.includes('air')) filterValue = 'air';
                else if (currentFilter.includes('radiant')) filterValue = 'radiant';
                
                displayKinBank(filterValue);
                updateDisplay();
                updateTeamDisplay();
                
                // Update total caught count
                gameState.totalKinCaught = gameState.kinBank.length;
                document.getElementById('totalCaught').textContent = gameState.totalKinCaught;
                
                // Update radiant count if needed
                const radiantCount = gameState.kinBank.filter(k => k.isRadiant).length;
                document.getElementById('radiantCount').textContent = radiantCount;
            }
        }
        
        function showKinDetails(kinId) {
            const kin = gameState.kinBank.find(k => k.id === kinId);
            if (!kin) return;
            
            const detailsModal = document.getElementById('kinDetails');
            const content = document.getElementById('kinDetailsContent');
            
            const xpProgress = ((kin.exp || 0) / getExpNeeded(kin.level || 1)) * 100;
            
            // Get stat ranges for comparison
            const ranges = {
                common: { hp: [120, 200], attack: [15, 29], speed: [12, 26], crit: [5, 10] },
                uncommon: { hp: [140, 230], attack: [18, 32], speed: [15, 29], crit: [6, 12] },
                rare: { hp: [160, 260], attack: [21, 35], speed: [18, 32], crit: [7, 14] },
                epic: { hp: [180, 290], attack: [24, 38], speed: [21, 35], crit: [8, 15] }
            };
            
            const range = ranges[kin.rarity];
            
            content.innerHTML = `
                <h2>${kin.name} Details</h2>
                <div style="text-align: center; margin: 20px 0;">
                    <div class="kinSprite ${kin.isRadiant ? 'radiant' : ''}">${getKinVisual(kin, 120)}</div>
                    <div class="rarity-${kin.rarity}">${kin.rarity.charAt(0).toUpperCase() + kin.rarity.slice(1)}${kin.isRadiant ? ' ✨ Radiant' : ''}</div>
                </div>
                
                <div style="margin: 20px 0;">
                    <h3>Stats Analysis</h3>
                    <div>HP: ${kin.stats.hp} / ${range.hp[1]} (${Math.round((kin.stats.hp - range.hp[0]) / (range.hp[1] - range.hp[0]) * 100)}%)</div>
                    <div>Attack: ${kin.stats.attack} / ${range.attack[1]} (${Math.round((kin.stats.attack - range.attack[0]) / (range.attack[1] - range.attack[0]) * 100)}%)</div>
                    <div>Speed: ${kin.stats.speed} / ${range.speed[1]} (${Math.round((kin.stats.speed - range.speed[0]) / (range.speed[1] - range.speed[0]) * 100)}%)</div>
                    <div>Crit Chance: ${kin.stats.crit || 10}% / ${range.crit[1]}% (${Math.round(((kin.stats.crit || 10) - range.crit[0]) / (range.crit[1] - range.crit[0]) * 100)}%)</div>
                </div>
                
                <div style="margin: 20px 0;">
                    <h3>Level Progress</h3>
                    <div>Level: ${kin.level || 1}</div>
                    <div>EXP: ${kin.exp || 0} / ${getExpNeeded(kin.level || 1)}</div>
                    <div class="expBar" style="width: 200px; height: 10px;">
                        <div class="expFill" style="width: ${xpProgress}%"></div>
                    </div>
                </div>
                
                <div style="margin: 20px 0;">
                    <h3>Attack Power</h3>
                    <div>Current: ${kin.attack.power} Power (${Math.round(kin.attack.modifier * 100)}% damage)</div>
                </div>
            `;
            
            detailsModal.style.display = 'block';
        }
        
        function closeKinDetails() {
            document.getElementById('kinDetails').style.display = 'none';
        }
        
        function releaseKin(kinId) {
            // Check if this is the last Kin
            if (gameState.kinBank.length <= 1) {
                showNotification('You must keep at least one Kin in your KinBank!');
                return;
            }
            
            if (confirm('Release this Kin? This cannot be undone!')) {
                // Remove from bank but keep in dex
                const index = gameState.kinBank.findIndex(k => k.id === kinId);
                if (index > -1) {
                    const kin = gameState.kinBank[index];
                    
                    // Remove from team if present
                    gameState.team = gameState.team.filter(k => k.id !== kinId);
                    
                    // Remove from bank
                    gameState.kinBank.splice(index, 1);
                    
                    showNotification(`Released ${kin.name}!`);
                    displayKinBank('all');
                    updateDisplay();
                    updateTeamDisplay();
                }
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Check for existing save
            try {
                const savedData = localStorage.getItem(SAVE_KEY);
                if (savedData) {
                    const saveData = JSON.parse(savedData);
                    if (confirm('Found existing save! Load it?')) {
                        loadSaveData(saveData);
                        showNotification('Welcome back! Save loaded.', 3000);
                        return;
                    }
                }
            } catch (e) {
                console.log('Could not check for existing save');
            }
            
            // Give starter Kin to new players
            const starter = giveStarterKin();
            showNotification(`You received ${starter.name} as your starter!`, 3000);
            
            updateDisplay();
            updateTeamDisplay();
            setInterval(updateBiomeTimers, 1000);
            setInterval(updateActiveEffectsDisplay, 1000); // Update effects display every second
            
            // Ensure encounters always run in background
    setInterval(() => {
        if (gameState.exploring && !gameState.encounterActive) {
            checkEncounters();
        }
    }, 1000);

    // Biome selection
            document.querySelectorAll('.biomeCard').forEach(card => {
                card.addEventListener('click', function() {
                    const biome = this.dataset.biome;
                    selectBiomeForExploration(biome);
                });
            });
            
            // Back button
            document.getElementById('backButton').addEventListener('click', leaveBiome);
        });

        // KinDex System
        function openKinDex() {
            const modal = document.getElementById('kinDexModal');
            modal.style.display = 'block';
            
            // Update statistics
            const stats = gameState.stats;
            document.getElementById('totalEncountered').textContent = stats.totalKinEncountered;
            document.getElementById('totalCaughtStat').textContent = gameState.totalKinCaught;
            
            const catchRate = stats.totalKinEncountered > 0 ? 
                Math.round((gameState.totalKinCaught / stats.totalKinEncountered) * 100) : 0;
            document.getElementById('catchRate').textContent = `${catchRate}%`;
            
            document.getElementById('radiantEncountered').textContent = stats.totalRadiantEncountered;
            document.getElementById('radiantCaughtStat').textContent = gameState.radiantDex.size;
            
            document.getElementById('totalGold').textContent = stats.totalGoldEarned.toLocaleString();
            
            // Police battle stats
            document.getElementById('policeWon').textContent = stats.policeBattlesWon;
            document.getElementById('policeLost').textContent = stats.policeBattlesLost;
            const policeTotal = stats.policeBattlesWon + stats.policeBattlesLost;
            const policeWinRate = policeTotal > 0 ? 
                Math.round((stats.policeBattlesWon / policeTotal) * 100) : 0;
            document.getElementById('policeWinRate').textContent = `${policeWinRate}%`;
            
            // Boxes found stat
            document.getElementById('totalBoxes').textContent = stats.totalBoxesFound;
            
            // Orbs used stats
            document.getElementById('commonOrbsUsed').textContent = stats.orbsUsed.common;
            document.getElementById('greatOrbsUsed').textContent = stats.orbsUsed.great;
            document.getElementById('rareOrbsUsed').textContent = stats.orbsUsed.rare;
            document.getElementById('epicOrbsUsed').textContent = stats.orbsUsed.epic;
            document.getElementById('legendaryOrbsUsed').textContent = stats.orbsUsed.legendary;
            
            // Progress stats
            document.getElementById('dexProgress').textContent = `${gameState.kinDex.size}/100`;
            
            displayKinDex();
        }
        
        function closeKinDex() {
            document.getElementById('kinDexModal').style.display = 'none';
        }
        
        function displayKinDex() {
            const grid = document.getElementById('kinDexGrid');
            grid.innerHTML = '';
            
            // Get all possible Kin from database
            const allKin = [];
            let kinNumber = 1;
            Object.keys(kinDatabase).forEach(element => {
                Object.keys(kinDatabase[element]).forEach(rarity => {
                    kinDatabase[element][rarity].forEach(kin => {
                        // Find the best overall stats for this Kin type
                        let bestOverallPercent = 0;
                        if (gameState.kinDex.has(kin.id)) {
                            // Check all caught instances of this Kin
                            const allCaughtOfType = gameState.kinBank.filter(k => k.id === kin.id);
                            allCaughtOfType.forEach(caughtKin => {
                                const overallPercent = getOverallStatPercent(caughtKin);
                                if (overallPercent > bestOverallPercent) {
                                    bestOverallPercent = overallPercent;
                                }
                            });
                        }
                        
                        allKin.push({
                            ...kin,
                            element: element,
                            rarity: rarity,
                            caught: gameState.kinDex.has(kin.id),
                            radiantCaught: gameState.radiantDex.has(kin.id),
                            number: kinNumber++,
                            bestOverallPercent: bestOverallPercent
                        });
                    });
                });
            });
            
            // Sort by element then rarity
            allKin.sort((a, b) => {
                const elementOrder = ['fire', 'water', 'earth', 'air'];
                const rarityOrder = ['common', 'uncommon', 'rare', 'epic'];
                
                if (a.element !== b.element) {
                    return elementOrder.indexOf(a.element) - elementOrder.indexOf(b.element);
                }
                return rarityOrder.indexOf(a.rarity) - rarityOrder.indexOf(b.rarity);
            });
            
            // Display each Kin
            allKin.forEach(kin => {
                const card = document.createElement('div');
                card.className = 'kinDexCard';
                if (kin.caught) {
                    card.classList.add('caught');
                    if (kin.radiantCaught) card.classList.add('radiant');
                }
                
                const rarityColors = {
                    common: '#e0e0e0',
                    uncommon: '#4CAF50',
                    rare: '#2196F3',
                    epic: '#9C27B0'
                };
                
                let statColor = '#666';
                if (kin.bestOverallPercent >= 75) statColor = '#4CAF50';
                else if (kin.bestOverallPercent >= 50) statColor = '#ff9800';
                else if (kin.bestOverallPercent >= 25) statColor = '#f44336';
                
                card.innerHTML = `
                    <div class="kinDexCardHeader">
                        <div class="kinDexName">${kin.caught ? kin.name : '???'}</div>
                        <div class="kinDexType ${kin.element}">${kin.element}</div>
                    </div>
                    <div class="kinDexRarity" style="color: ${rarityColors[kin.rarity]};">
                        ${kin.rarity}
                    </div>
                    ${kin.caught && kin.bestOverallPercent > 0 ? `
                        <div class="kinDexHighStat" style="color: ${statColor};">
                            Best: ${kin.bestOverallPercent}%
                            <span class="tooltip">Highest overall stats caught</span>
                        </div>
                    ` : ''}
                    <div class="kinDexNumber">#${String(kin.number).padStart(3, '0')}</div>
                    <div class="kinDexIcon">${kin.caught ? getKinVisual(kin, 120) : '?'}</div>
                    <div class="kinDexStatus ${kin.caught ? 'caught' : 'notCaught'}">
                        ${kin.caught ? '✓ Caught' : '✗ Not Caught'}
                    </div>
                    ${kin.radiantCaught ? '<div class="kinDexRadiant">✨ Radiant Caught</div>' : ''}
                `;
                
                grid.appendChild(card);
            });
        }
        
        function getOverallStatPercent(kin) {
            const ranges = {
                common: { hp: [120, 200], attack: [15, 29], speed: [12, 26], crit: [5, 10] },
                uncommon: { hp: [140, 230], attack: [18, 32], speed: [15, 29], crit: [6, 12] },
                rare: { hp: [160, 260], attack: [21, 35], speed: [18, 32], crit: [7, 14] },
                epic: { hp: [180, 290], attack: [24, 38], speed: [21, 35], crit: [8, 15] }
            };
            
            const range = ranges[kin.rarity];
            const hpPercent = Math.round((kin.stats.hp - range.hp[0]) / (range.hp[1] - range.hp[0]) * 100);
            const atkPercent = Math.round((kin.stats.attack - range.attack[0]) / (range.attack[1] - range.attack[0]) * 100);
            const spdPercent = Math.round((kin.stats.speed - range.speed[0]) / (range.speed[1] - range.speed[0]) * 100);
            const critPercent = Math.round(((kin.stats.crit || 10) - range.crit[0]) / (range.crit[1] - range.crit[0]) * 100);
            
            return Math.round((hpPercent + atkPercent + spdPercent + critPercent) / 4);
        }
        
        // KinBag System
        function openKinBag() {
            const modal = document.getElementById('kinBagModal');
            modal.style.display = 'block';
            
            displayKinBag();
        }
        
        function closeKinBag() {
            document.getElementById('kinBagModal').style.display = 'none';
        }
        
        function displayKinBag() {
            const content = document.getElementById('kinBagContent');
            content.innerHTML = '';
            
            // Display orbs
            const orbItems = [
                { name: 'Orb', count: gameState.orbs.common, icon: '⚪', desc: '60% catch rate' },
                { name: 'Great Orb', count: gameState.orbs.great, icon: '🟢', desc: '70% catch rate' },
                { name: 'Rare Orb', count: gameState.orbs.rare, icon: '🔵', desc: '80% catch rate' },
                { name: 'Epic Orb', count: gameState.orbs.epic, icon: '🟣', desc: '90% catch rate' },
                { name: 'Legendary Orb', count: gameState.orbs.legendary, icon: '⭐', desc: '99% catch rate' }
            ];
            
            orbItems.forEach(item => {
                if (item.count > 0) {
                    const itemCard = document.createElement('div');
                    itemCard.className = 'kinCard';
                    itemCard.innerHTML = `
                        <div style="text-align: center;">
                            <div style="font-size: 48px;">${item.icon}</div>
                            <div style="font-weight: bold;">${item.name}</div>
                            <div style="font-size: 14px; color: #888;">${item.desc}</div>
                            <div style="font-size: 20px; margin-top: 10px;">x${item.count}</div>
                        </div>
                    `;
                    content.appendChild(itemCard);
                }
            });
            
            // Add other items here when implemented (Lures, Radiant Collectors, etc.)
            
            if (content.children.length === 0) {
                content.innerHTML = '<div style="text-align: center; color: #888; grid-column: span 4;">Your bag is empty!</div>';
            }
        }
        
        // Biome Protectors Data
        const biomeProtectors = {
            fire: [
                { id: 'ashen', name: 'Ashen', icon: '🔥', level: 10, reward: { gold: 100, orbs: 5 } , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Fire/ashen.png' },
                { id: 'blazic', name: 'Blazic', icon: '🔥', level: 20, reward: { gold: 250, rare_orbs: 2 } , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Fire/blazic.png' },
                { id: 'embrax', name: 'Embrax', icon: '🔥', level: 30, reward: { gold: 500, epic_orbs: 1 } , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Fire/embrax.png' },
                { id: 'ignara', name: 'Ignara', icon: '🔥', level: 40, reward: { gold: 1000, legendary_orb: 1 } , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Fire/ignara.png' },
            ],
            water: [
                { id: 'mira', name: 'Mira', icon: '💧', level: 10, reward: { gold: 100, orbs: 5 } , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Water/mira.png' },
                { id: 'nerida', name: 'Nerida', icon: '💧', level: 20, reward: { gold: 250, rare_orbs: 2 } , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Water/nerida.png' },
                { id: 'marinel', name: 'Marinel', icon: '💧', level: 30, reward: { gold: 500, epic_orbs: 1 } , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Water/marinel.png' },
                { id: 'oceara', name: 'Oceara', icon: '💧', level: 40, reward: { gold: 1000, legendary_orb: 1 } , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Water/oceara.png' },
            ],
            earth: [
                { id: 'pebble', name: 'Pebble', icon: '🪨', level: 10, reward: { gold: 100, orbs: 5 } , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Earth/pebble.png' },
                { id: 'terranox', name: 'Terranox', icon: '🪨', level: 20, reward: { gold: 250, rare_orbs: 2 } , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Earth/terranox.png' },
                { id: 'gravik', name: 'Gravik', icon: '🪨', level: 30, reward: { gold: 500, epic_orbs: 1 } , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Earth/gravik.png' },
                { id: 'gaialith', name: 'Gaialith', icon: '🪨', level: 40, reward: { gold: 1000, legendary_orb: 1 } , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Earth/gaialith.png' },
            ],
            air: [
                { id: 'breezi', name: 'Breezi', icon: '💨', level: 10, reward: { gold: 100, orbs: 5 } , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Air/breezi.png' },
                { id: 'zephra', name: 'Zephra', icon: '💨', level: 20, reward: { gold: 250, rare_orbs: 2 } , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Air/zephra.png' },
                { id: 'aeronox', name: 'Aeronox', icon: '💨', level: 30, reward: { gold: 500, epic_orbs: 1 } , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Air/aeronox.png' },
                { id: 'stratos', name: 'Stratos', icon: '💨', level: 40, reward: { gold: 1000, legendary_orb: 1 } , image: 'https://raw.githubusercontent.com/Graphic37/KinBound/main/Kin/Air/stratos.png' },
            ]
        };
        
        // Challenges System
        function openChallenges() {
            const modal = document.getElementById('challengesModal');
            modal.style.display = 'block';
            displayChallenges();
        }
        
        function closeChallenges() {
            document.getElementById('challengesModal').style.display = 'none';
        }
        
        function displayChallenges() {
            const content = document.getElementById('challengesContent');
            content.innerHTML = '';
            
            const biomes = ['fire', 'water', 'earth', 'air'];
            const biomeNames = {
                fire: 'The Ashen Peaks',
                water: 'The Sunken Grotto',
                earth: 'The Tectonic Scar',
                air: 'The Howling Spires'
            };
            const biomeIcons = {
                fire: '🔥',
                water: '💧',
                earth: '🌍',
                air: '💨'
            };
            
            biomes.forEach(biome => {
                const biomeSection = document.createElement('div');
                biomeSection.className = 'biomeProtectors';
                
                // Count defeated protectors
                const totalProtectors = biomeProtectors[biome].length;
                const defeatedCount = gameState.protectorsDefeated[biome].length;
                const isComplete = defeatedCount === totalProtectors;
                
                const header = document.createElement('div');
                header.className = 'biomeProtectorsHeader';
                header.innerHTML = `
                    ${biomeIcons[biome]} ${biomeNames[biome]}
                    <span class="biomeCompletion ${isComplete ? 'complete' : ''}">
                        ${defeatedCount}/${totalProtectors} Complete
                    </span>
                `;
                biomeSection.appendChild(header);
                
                biomeProtectors[biome].forEach((protector, index) => {
                    const isDefeated = gameState.protectorsDefeated[biome].includes(protector.id);
                    const highestLevel = getHighestTeamLevel();
                    const canChallenge = highestLevel >= Math.max(1, protector.level - 10);
                    
                    const card = document.createElement('div');
                    card.className = 'protectorCard';
                    if (isDefeated) card.classList.add('defeated');
                    else if (canChallenge) card.classList.add('canChallenge');
                    else card.classList.add('locked');
                    
                    // Get team tier info
                    let tierName = '';
                    let tierColor = '';
                    if (protector.level === 10) {
                        tierName = 'Novice';
                        tierColor = '#e0e0e0';
                    } else if (protector.level === 20) {
                        tierName = 'Easy';
                        tierColor = '#4CAF50';
                    } else if (protector.level === 30) {
                        tierName = 'Medium';
                        tierColor = '#2196F3';
                    } else if (protector.level === 40) {
                        tierName = 'Hard';
                        tierColor = '#9C27B0';
                    }
                    
                    card.innerHTML = `
                        <div class="protectorBadge">
                            <div class="protectorIcon">${protector.icon}</div>
                            <div class="protectorLevel">Lv.${protector.level}</div>
                            <div style="font-size: 11px; color: ${tierColor}; font-weight: 600; text-transform: uppercase;">
                                ${tierName}
                            </div>
                        </div>
                        <div class="protectorContent">
                            <div class="protectorInfo">
                                <div class="protectorName">${protector.name}</div>
                                <div class="protectorTeamInfo">
                                    Team: ${getProtectorTeamDescription(protector.level)}
                                </div>
                                <div class="protectorStatus" style="color: ${canChallenge ? '#4CAF50' : '#ff6666'};">
                                    ${canChallenge ? '✓ Ready to challenge' : `⚠️ Need level ${Math.max(1, protector.level - 10)}+ (You: Lv.${highestLevel})`}
                                </div>
                                <div class="protectorReward">
                                    🎁 ${formatReward(protector.reward)}
                                </div>
                            </div>
                            <div class="protectorActions">
                                ${isDefeated ? `
                                    <div class="defeatedBadge">
                                        ✓ Defeated
                                    </div>
                                ` : `
                                    <button class="orbButton" onclick="challengeProtector('${biome}', '${protector.id}')" 
                                        ${!canChallenge ? 'disabled title="Level up your team more!"' : ''}>
                                        Challenge
                                    </button>
                                `}
                            </div>
                        </div>
                    `;
                    
                    biomeSection.appendChild(card);
                });
                
                content.appendChild(biomeSection);
            });
        }
        
        function getProtectorTeamDescription(level) {
            if (level === 10) return '4 Common Kin (Lv.5-10)';
            if (level === 20) return '4 Uncommon Kin (Lv.10-20)';
            if (level === 30) return '4 Rare Kin (Lv.20-30)';
            if (level === 40) return '4 Epic Kin (Lv.30-40)';
            return '4 Kin';
        }
        
        function getHighestTeamLevel() {
            if (gameState.team.length === 0) return 1;
            return Math.max(...gameState.team.map(k => k.level || 1));
        }
        
        function formatReward(reward) {
            const parts = [];
            if (reward.gold) parts.push(`${reward.gold} Gold`);
            if (reward.orbs) parts.push(`${reward.orbs} Orbs`);
            if (reward.rare_orbs) parts.push(`${reward.rare_orbs} Rare Orb${reward.rare_orbs > 1 ? 's' : ''}`);
            if (reward.epic_orbs) parts.push(`${reward.epic_orbs} Epic Orb${reward.epic_orbs > 1 ? 's' : ''}`);
            if (reward.legendary_orb) parts.push(`${reward.legendary_orb} Legendary Orb`);
            return parts.join(', ');
        }
        
        function challengeProtector(biome, protectorId) {
            const protector = biomeProtectors[biome].find(p => p.id === protectorId);
            if (!protector) return;
            
            if (gameState.team.length === 0) {
                showNotification('You need a team to challenge protectors!');
                return;
            }
            
            // Close challenges modal
            closeChallenges();
            
            // Generate protector's team
            const protectorTeam = generateProtectorTeam(biome, protector);
            
            // Start the battle directly
            gameState.encounterActive = true;
            
            const modal = document.getElementById('encounterModal');
            modal.style.display = 'block';
            
            // Go straight to battle
            startProtectorBattlePhase(protectorTeam, protector, biome);
        }
        
        function generateProtectorTeam(biome, protector) {
            const team = [];
            
            // Always create a team of 4 Kin based on protector tier
            let rarity, levelRange;
            
            // Determine rarity and level range based on protector level
            if (protector.level === 10) {
                // Tier 1: Common Kin, levels 5-10
                rarity = 'common';
                levelRange = [5, 10];
            } else if (protector.level === 20) {
                // Tier 2: Uncommon Kin, levels 10-20
                rarity = 'uncommon';
                levelRange = [10, 20];
            } else if (protector.level === 30) {
                // Tier 3: Rare Kin, levels 20-30
                rarity = 'rare';
                levelRange = [20, 30];
            } else if (protector.level === 40) {
                // Tier 4: Epic Kin, levels 30-40
                rarity = 'epic';
                levelRange = [30, 40];
            }
            
            // Generate 4 Kin of the appropriate rarity
            for (let i = 0; i < 4; i++) {
                const kinList = kinDatabase[biome][rarity];
                const kinBase = kinList[Math.floor(Math.random() * kinList.length)];
                
                // Generate the Kin with appropriate stats
                const kin = {
                    ...kinBase,
                    element: biome,
                    rarity: rarity,
                    isRadiant: false,
                    level: randomBetween(levelRange[0], levelRange[1]),
                    stats: generateStats(rarity, false),
                    attack: getRandomAttack()
                };
                
                // Apply level scaling to stats
                kin.stats.hp = Math.floor(kin.stats.hp * (1 + (kin.level - 1) * 0.1));
                kin.stats.attack = Math.floor(kin.stats.attack * (1 + (kin.level - 1) * 0.1));
                kin.stats.speed = Math.floor(kin.stats.speed * (1 + (kin.level - 1) * 0.1));
                kin.currentHp = kin.stats.hp;
                kin.maxHp = kin.stats.hp;
                
                team.push(kin);
            }
            
            return team;
        }
        
        function startProtectorBattlePhase(protectorTeam, protector, biome) {
            const modal = document.getElementById('encounterModal');
            const content = document.getElementById('encounterContent');
            
            // Add biome-themed background to the entire modal
            const biomeBackgrounds = {
                fire: 'radial-gradient(ellipse at center, rgba(255, 87, 34, 0.3), rgba(139, 0, 0, 0.2), rgba(0, 0, 0, 0.8))',
                water: 'radial-gradient(ellipse at center, rgba(33, 150, 243, 0.3), rgba(0, 51, 102, 0.2), rgba(0, 0, 0, 0.8))',
                earth: 'radial-gradient(ellipse at center, rgba(139, 105, 20, 0.3), rgba(101, 67, 33, 0.2), rgba(0, 0, 0, 0.8))',
                air: 'radial-gradient(ellipse at center, rgba(156, 39, 176, 0.3), rgba(69, 39, 160, 0.2), rgba(0, 0, 0, 0.8))'
            };
            
            // Create a background overlay
            const existingBg = document.getElementById('battleBackground');
            if (existingBg) existingBg.remove();
            
            const battleBg = document.createElement('div');
            battleBg.id = 'battleBackground';
            battleBg.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: ${biomeBackgrounds[biome]};
                z-index: 99;
                pointer-events: none;
            `;
            document.body.appendChild(battleBg);
            
            // Prepare battle state
            const playerTeam = gameState.team.map(k => ({
                ...k,
                currentHp: k.stats.hp,
                maxHp: k.stats.hp
            }));
            
            const enemyTeam = protectorTeam.map(k => ({
                ...k,
                currentHp: k.stats.hp || k.currentHp,
                maxHp: k.stats.hp || k.maxHp
            }));
            
            let battleLog = [];
            let playerIndex = 0;
            let enemyIndex = 0;
            let turnCount = 0;
            
            // Get active fighters
            function getActiveFighters() {
                const playerKin = playerTeam[playerIndex];
                const enemyKin = enemyTeam[enemyIndex];
                return { playerKin, enemyKin };
            }
            
            // Auto-battle logic - now 1v1
            function battleTurn() {
                turnCount++;
                const { playerKin, enemyKin } = getActiveFighters();
                
                // Determine turn order based on speed
                const fighters = [
                    { kin: playerKin, isPlayer: true },
                    { kin: enemyKin, isPlayer: false }
                ].sort((a, b) => b.kin.stats.speed - a.kin.stats.speed);
                
                // Process each fighter's attack
                for (const fighter of fighters) {
                    if (fighter.kin.currentHp <= 0) continue;
                    
                    const target = fighter.isPlayer ? enemyKin : playerKin;
                    if (target.currentHp <= 0) continue;
                    
                    const damageResult = calculateDamage(fighter.kin, target);
                    const damage = damageResult.damage;
                    const typeMultiplier = damageResult.typeMultiplier;
                    const isCrit = damageResult.isCrit;
                    
                    target.currentHp = Math.max(0, target.currentHp - damage);
                    
                    // Add detailed battle log
                    let logMessage = `${fighter.kin.name} uses ${getAttackName(fighter.kin.attack)} Attack!`;
                    battleLog.push(logMessage);
                    
                    logMessage = `→ Deals ${damage} damage to ${target.name}`;
                    if (isCrit) logMessage += ' (Crit)';
                    if (typeMultiplier > 1) logMessage += ' (Super effective!)';
                    else if (typeMultiplier < 1) logMessage += ' (Not very effective...)';
                    battleLog.push(logMessage);
                    
                    if (target.currentHp === 0) {
                        battleLog.push(`${target.name} fainted!`);
                        
                        // Move to next Kin
                        if (fighter.isPlayer) {
                            enemyIndex++;
                            if (enemyIndex < enemyTeam.length) {
                                battleLog.push(`Enemy sends out ${enemyTeam[enemyIndex].name}!`);
                            }
                        } else {
                            playerIndex++;
                            if (playerIndex < playerTeam.length) {
                                battleLog.push(`You send out ${playerTeam[playerIndex].name}!`);
                            }
                        }
                    }
                }
                
                // Check battle end
                const playerHasKin = playerIndex < playerTeam.length && playerTeam[playerIndex].currentHp > 0;
                const enemyHasKin = enemyIndex < enemyTeam.length && enemyTeam[enemyIndex].currentHp > 0;
                
                if (!playerHasKin || !enemyHasKin) {
                    endProtectorBattle(playerHasKin, protector, biome, battleLog);
                    return;
                }
                
                // Update display
                updateBattleDisplay();
                setTimeout(battleTurn, 1500);
            }
            
            function getAttackName(attack) {
                if (attack.power === 10) return 'Basic';
                if (attack.power === 20) return 'Strong';
                if (attack.power === 30) return 'Power';
                return 'Unknown';
            }
            
            function calculateDamage(attacker, defender) {
                const baseDamage = attacker.stats.attack * attacker.attack.modifier;
                const typeMultiplier = getTypeMultiplier(attacker.element, defender.element);
                
                // Check for critical hit
                const critChance = attacker.stats.crit || 10;
                const isCrit = Math.random() * 100 < critChance;
                const critMultiplier = isCrit ? 1.5 : 1.0;
                
                const totalDamage = Math.floor(baseDamage * typeMultiplier * critMultiplier);
                
                return { damage: totalDamage, isCrit: isCrit, typeMultiplier: typeMultiplier };
            }
            
            function getTypeMultiplier(attackType, defendType) {
                const effectiveness = {
                    fire: { earth: 1.2, water: 0.8, air: 1.0, fire: 1.0 },
                    water: { fire: 1.2, air: 0.8, earth: 1.0, water: 1.0 },
                    earth: { air: 1.2, fire: 0.8, water: 1.0, earth: 1.0 },
                    air: { water: 1.2, earth: 0.8, fire: 1.0, air: 1.0 }
                };
                
                if (effectiveness[attackType] && effectiveness[attackType][defendType]) {
                    return effectiveness[attackType][defendType];
                }
                return 1.0;
            }
            
            function updateBattleDisplay() {
                const { playerKin, enemyKin } = getActiveFighters();
                
                content.innerHTML = `
                    <div style="text-align: center; margin-bottom: 20px;">
                        <h2 style="margin: 0; font-size: 28px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);">
                            ${protector.name} Challenge
                        </h2>
                        <div style="font-size: 16px; color: #888; margin-top: 5px;">Turn ${turnCount}</div>
                    </div>
                    
                    <div style="display: flex; justify-content: space-between; align-items: center; margin: 0 auto; max-width: 1200px;">
                        <!-- Player Side -->
                        <div style="flex: 1; text-align: center;">
                            <div style="background: linear-gradient(135deg, rgba(0,255,0,0.1), rgba(0,100,0,0.2)); 
                                        padding: 20px; border-radius: 15px; border: 2px solid rgba(0,255,0,0.3);
                                        box-shadow: 0 10px 30px rgba(0,0,0,0.5);">
                                <div style="font-size: 100px; margin: 20px 0; filter: drop-shadow(0 5px 10px rgba(0,0,0,0.5));
                                            animation: float 3s ease-in-out infinite;">
                                    ${getKinVisual(playerKin)}
                                </div>
                                <div style="font-size: 24px; font-weight: bold; margin-bottom: 10px;">
                                    ${playerKin.name}
                                </div>
                                <div style="display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 10px;">
                                    <span style="background: rgba(0,0,0,0.3); padding: 4px 12px; border-radius: 15px; font-size: 14px;">
                                        Lv.${playerKin.level || 1}
                                    </span>
                                    <span style="background: rgba(0,0,0,0.3); padding: 4px 12px; border-radius: 15px; font-size: 14px; text-transform: capitalize;">
                                        ${playerKin.element}
                                    </span>
                                </div>
                                
                                <!-- HP Bar -->
                                <div style="margin: 15px 0;">
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                        <span style="font-size: 14px;">HP</span>
                                        <span style="font-size: 14px;">${playerKin.currentHp}/${playerKin.maxHp}</span>
                                    </div>
                                    <div style="background: #1a1a1a; height: 25px; border-radius: 15px; overflow: hidden; 
                                                box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);">
                                        <div style="background: ${getHealthGradient(playerKin.currentHp, playerKin.maxHp)}; 
                                                    width: ${(playerKin.currentHp/playerKin.maxHp)*100}%; 
                                                    height: 100%; transition: width 0.5s; position: relative;">
                                            <div style="position: absolute; inset: 0; 
                                                        background: linear-gradient(180deg, rgba(255,255,255,0.3) 0%, transparent 50%, rgba(0,0,0,0.2) 100%);"></div>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Stats -->
                                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-top: 15px;">
                                    <div style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 8px;">
                                        <div style="font-size: 12px; color: #888;">ATK</div>
                                        <div style="font-size: 18px; font-weight: bold;">${playerKin.stats.attack}</div>
                                    </div>
                                    <div style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 8px;">
                                        <div style="font-size: 12px; color: #888;">SPD</div>
                                        <div style="font-size: 18px; font-weight: bold;">${playerKin.stats.speed}</div>
                                    </div>
                                    <div style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 8px;">
                                        <div style="font-size: 12px; color: #888;">CRIT</div>
                                        <div style="font-size: 18px; font-weight: bold;">${playerKin.stats.crit || 10}%</div>
                                    </div>
                                </div>
                                
                                <!-- Attack Info -->
                                <div style="margin-top: 10px; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px;">
                                    <div style="font-size: 12px; color: #888; margin-bottom: 4px;">Attack Type</div>
                                    <div style="font-size: 16px; font-weight: bold; color: #4CAF50;">
                                        ${getAttackName(playerKin.attack)} Attack
                                    </div>
                                    <div style="font-size: 14px; color: #aaa;">
                                        ${playerKin.attack.power} Power (${Math.round(playerKin.attack.modifier * 100)}% DMG)
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Team List -->
                            <div style="margin-top: 20px; background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px;">
                                <div style="font-weight: bold; margin-bottom: 10px;">Your Team</div>
                                ${playerTeam.map((k, i) => `
                                    <div style="display: flex; align-items: center; justify-content: space-between; 
                                                padding: 5px 10px; margin: 5px 0; border-radius: 5px;
                                                background: ${i === playerIndex ? 'rgba(0,255,0,0.2)' : 'transparent'};
                                                opacity: ${k.currentHp === 0 ? 0.5 : 1};">
                                        <div style="display: flex; align-items: center; gap: 10px;">
                                            <span style="font-size: 20px;">${getKinVisual(k, 40)}</span>
                                            <span>Lv.${k.level || 1} ${k.name}</span>
                                        </div>
                                        <div style="font-size: 12px;">
                                            ${k.currentHp}/${k.maxHp}
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        
                        <!-- VS Divider -->
                        <div style="padding: 0 40px;">
                            <div style="font-size: 48px; font-weight: bold; color: #666; 
                                        text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
                                        animation: pulse 2s ease-in-out infinite;">
                                VS
                            </div>
                        </div>
                        
                        <!-- Enemy Side -->
                        <div style="flex: 1; text-align: center;">
                            <div style="background: linear-gradient(135deg, rgba(255,0,0,0.1), rgba(100,0,0,0.2)); 
                                        padding: 20px; border-radius: 15px; border: 2px solid rgba(255,0,0,0.3);
                                        box-shadow: 0 10px 30px rgba(0,0,0,0.5);">
                                <div style="font-size: 100px; margin: 20px 0; filter: drop-shadow(0 5px 10px rgba(0,0,0,0.5));
                                            animation: float 3s ease-in-out infinite; animation-delay: 1.5s;">
                                    ${getKinVisual(enemyKin)}
                                </div>
                                <div style="font-size: 24px; font-weight: bold; margin-bottom: 10px;">
                                    ${enemyKin.name}
                                </div>
                                <div style="display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 10px;">
                                    <span style="background: rgba(0,0,0,0.3); padding: 4px 12px; border-radius: 15px; font-size: 14px;">
                                        Lv.${enemyKin.level || 1}
                                    </span>
                                    <span style="background: rgba(0,0,0,0.3); padding: 4px 12px; border-radius: 15px; font-size: 14px; text-transform: capitalize;">
                                        ${enemyKin.element}
                                    </span>
                                </div>
                                
                                <!-- HP Bar -->
                                <div style="margin: 15px 0;">
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                        <span style="font-size: 14px;">HP</span>
                                        <span style="font-size: 14px;">${enemyKin.currentHp}/${enemyKin.maxHp}</span>
                                    </div>
                                    <div style="background: #1a1a1a; height: 25px; border-radius: 15px; overflow: hidden; 
                                                box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);">
                                        <div style="background: ${getHealthGradient(enemyKin.currentHp, enemyKin.maxHp)}; 
                                                    width: ${(enemyKin.currentHp/enemyKin.maxHp)*100}%; 
                                                    height: 100%; transition: width 0.5s; position: relative;">
                                            <div style="position: absolute; inset: 0; 
                                                        background: linear-gradient(180deg, rgba(255,255,255,0.3) 0%, transparent 50%, rgba(0,0,0,0.2) 100%);"></div>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Stats -->
                                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-top: 15px;">
                                    <div style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 8px;">
                                        <div style="font-size: 12px; color: #888;">ATK</div>
                                        <div style="font-size: 18px; font-weight: bold;">${enemyKin.stats.attack}</div>
                                    </div>
                                    <div style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 8px;">
                                        <div style="font-size: 12px; color: #888;">SPD</div>
                                        <div style="font-size: 18px; font-weight: bold;">${enemyKin.stats.speed}</div>
                                    </div>
                                    <div style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 8px;">
                                        <div style="font-size: 12px; color: #888;">CRIT</div>
                                        <div style="font-size: 18px; font-weight: bold;">${enemyKin.stats.crit || 10}%</div>
                                    </div>
                                </div>
                                
                                <!-- Attack Info -->
                                <div style="margin-top: 10px; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px;">
                                    <div style="font-size: 12px; color: #888; margin-bottom: 4px;">Attack Type</div>
                                    <div style="font-size: 16px; font-weight: bold; color: #ff6666;">
                                        ${getAttackName(enemyKin.attack)} Attack
                                    </div>
                                    <div style="font-size: 14px; color: #aaa;">
                                        ${enemyKin.attack.power} Power (${Math.round(enemyKin.attack.modifier * 100)}% DMG)
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Team List -->
                            <div style="margin-top: 20px; background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px;">
                                <div style="font-weight: bold; margin-bottom: 10px;">Guardian's Team</div>
                                ${enemyTeam.map((k, i) => `
                                    <div style="display: flex; align-items: center; justify-content: space-between; 
                                                padding: 5px 10px; margin: 5px 0; border-radius: 5px;
                                                background: ${i === enemyIndex ? 'rgba(255,0,0,0.2)' : 'transparent'};
                                                opacity: ${k.currentHp === 0 ? 0.5 : 1};">
                                        <div style="display: flex; align-items: center; gap: 10px;">
                                            <span style="font-size: 20px;">${getKinVisual(k, 40)}</span>
                                            <span>Lv.${k.level || 1} ${k.name}</span>
                                        </div>
                                        <div style="font-size: 12px;">
                                            ${k.currentHp}/${k.maxHp}
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                    
                    <!-- Battle Log -->
                    <div style="max-width: 800px; margin: 30px auto 0; background: rgba(0,0,0,0.5); 
                                padding: 15px; border-radius: 10px; max-height: 150px; overflow-y: auto;
                                border: 1px solid rgba(255,255,255,0.1);">
                        <div style="font-weight: bold; margin-bottom: 10px; text-align: center;">Battle Log</div>
                        ${battleLog.slice(-8).map(log => `
                            <div style="margin: 4px 0; padding: 4px 8px; border-radius: 5px; 
                                        background: rgba(255,255,255,0.05); font-size: 14px;">
                                ${log}
                            </div>
                        `).join('')}
                    </div>
                    
                    <style>
                        @keyframes float {
                            0%, 100% { transform: translateY(0px); }
                            50% { transform: translateY(-10px); }
                        }
                        @keyframes pulse {
                            0%, 100% { opacity: 0.6; transform: scale(1); }
                            50% { opacity: 1; transform: scale(1.1); }
                        }
                    </style>
                `;
            }
            
            function getHealthGradient(current, max) {
                const percent = current / max;
                if (percent > 0.5) return 'linear-gradient(90deg, #4CAF50, #45a049)';
                if (percent > 0.25) return 'linear-gradient(90deg, #ff9800, #f57c00)';
                return 'linear-gradient(90deg, #f44336, #d32f2f)';
            }
            
            function getHealthColor(current, max) {
                const percent = current / max;
                if (percent > 0.5) return '#4CAF50';
                if (percent > 0.25) return '#ff9800';
                return '#f44336';
            }
            
            // Start the battle
            updateBattleDisplay();
            setTimeout(battleTurn, 1000);
        }
        
        function endProtectorBattle(playerWon, protector, biome, battleLog) {
            const content = document.getElementById('encounterContent');
            
            if (playerWon) {
                // Mark as defeated
                if (!gameState.protectorsDefeated[biome].includes(protector.id)) {
                    gameState.protectorsDefeated[biome].push(protector.id);
                }
                
                // Give rewards
                const reward = protector.reward;
                if (reward.gold) {
                    gameState.gold += reward.gold;
                    gameState.stats.totalGoldEarned += reward.gold;
                }
                if (reward.orbs) gameState.orbs.common += reward.orbs;
                if (reward.rare_orbs) gameState.orbs.rare += reward.rare_orbs;
                if (reward.epic_orbs) gameState.orbs.epic += reward.epic_orbs;
                if (reward.legendary_orb) gameState.orbs.legendary += reward.legendary_orb;
                
                gameState.stats.protectorBattlesWon++;
                
                // Give lots of EXP
                const expReward = protector.level * 25;
                const levelUps = [];
                
                gameState.team.forEach(kin => {
                    const oldLevel = kin.level || 1;
                    kin.exp = (kin.exp || 0) + expReward;
                    while (kin.exp >= getExpNeeded(kin.level || 1)) {
                        kin.exp -= getExpNeeded(kin.level || 1);
                        kin.level = (kin.level || 1) + 1;
                        levelUpStats(kin);
                    }
                    if (kin.level > oldLevel) {
                        levelUps.push({ name: kin.name, oldLevel: oldLevel, newLevel: kin.level });
                    }
                });
                
                content.innerHTML = `
                    <h2 style="color: gold;">LEGENDARY VICTORY!</h2>
                    <div style="margin: 20px 0;">
                        <div style="background: rgba(255,215,0,0.1); padding: 15px; border-radius: 5px; margin-bottom: 15px;">
                            <div style="font-size: 24px; color: gold; margin-bottom: 10px;">
                                You defeated ${protector.icon} ${protector.name}!
                            </div>
                            <div style="font-size: 20px; margin-bottom: 10px;">Protector Rewards:</div>
                            <div style="color: #4CAF50; font-size: 18px;">
                                ${formatReward(reward).split(', ').map(r => `<div>• ${r}</div>`).join('')}
                            </div>
                            <div style="margin-top: 10px;">⭐ All Kin gained ${expReward} EXP!</div>
                            ${levelUps.length > 0 ? `
                                <div style="margin-top: 10px; color: #4CAF50;">
                                    <div style="font-weight: bold;">Level Ups:</div>
                                    ${levelUps.map(lu => `<div>• ${lu.name} reached level ${lu.newLevel}!</div>`).join('')}
                                </div>
                            ` : ''}
                        </div>
                        
                        <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; max-height: 300px; overflow-y: auto;">
                            <div style="font-weight: bold; margin-bottom: 5px;">Complete Battle Log:</div>
                            ${battleLog.map((log, i) => `<div style="margin: 2px 0;">• ${log}</div>`).join('')}
                        </div>
                    </div>
                    <button class="orbButton" onclick="closeEncounter()" style="font-size: 18px; padding: 15px 30px;">
                        Continue
                    </button>
                `;
                
                showNotification(`Defeated ${protector.name}!`, 3000);
            } else {
                gameState.stats.protectorBattlesLost++;
                content.innerHTML = `
                    <h2 style="color: #ff6666;">Defeated!</h2>
                    <div style="margin: 20px 0;">
                        <div style="background: rgba(255,0,0,0.1); padding: 15px; border-radius: 5px; margin-bottom: 15px;">
                            <div style="font-size: 20px; margin-bottom: 10px;">${protector.name} was too powerful!</div>
                            <div>Train your team and try again!</div>
                            <div style="margin-top: 10px; font-size: 14px; color: #888;">
                                Tip: Make sure your team levels are close to the recommended level ${protector.level}
                            </div>
                        </div>
                        
                        <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; max-height: 300px; overflow-y: auto;">
                            <div style="font-weight: bold; margin-bottom: 5px;">Complete Battle Log:</div>
                            ${battleLog.map((log, i) => `<div style="margin: 2px 0;">• ${log}</div>`).join('')}
                        </div>
                    </div>
                    <button class="orbButton" onclick="closeEncounter()" style="font-size: 18px; padding: 15px 30px;">
                        Continue
                    </button>
                `;
            }
            
            updateDisplay();
        }
        
        // Save/Load System
        const SAVE_KEY = 'kinbound_save';
        const SAVE_VERSION = '1.0';
        
        function openSaveLoad() {
            document.getElementById('saveLoadModal').style.display = 'block';
            checkAutoSaveStatus();
        }
        
        function closeSaveLoad() {
            document.getElementById('saveLoadModal').style.display = 'none';
        }
        
        function checkAutoSaveStatus() {
            const info = document.getElementById('autoSaveInfo');
            try {
                const savedData = localStorage.getItem(SAVE_KEY);
                if (savedData) {
                    const saveData = JSON.parse(savedData);
                    const saveDate = new Date(saveData.timestamp);
                    info.innerHTML = `
                        <strong>✅ Save found!</strong><br>
                        Last saved: ${saveDate.toLocaleDateString()} at ${saveDate.toLocaleTimeString()}<br>
                        Kin caught: ${saveData.gameState.totalKinCaught}<br>
                        Gold: ${saveData.gameState.gold}
                    `;
                    info.classList.add('show');
                } else {
                    info.innerHTML = '<strong>❌ No save found in browser</strong>';
                    info.classList.add('show');
                }
            } catch (e) {
                info.innerHTML = '<strong>⚠️ LocalStorage not available in this environment</strong><br>Use Download/Upload or Save Codes instead.';
                info.classList.add('show');
            }
        }
        
        function prepareSaveData() {
            // Convert Sets to Arrays for JSON serialization
            const saveData = {
                version: SAVE_VERSION,
                timestamp: Date.now(),
                gameState: {
                    ...gameState,
                    kinDex: Array.from(gameState.kinDex),
                    radiantDex: Array.from(gameState.radiantDex)
                }
            };
            return saveData;
        }
        
        function saveToLocalStorage() {
            try {
                const saveData = prepareSaveData();
                localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
                showNotification('Game saved successfully!');
                checkAutoSaveStatus();
            } catch (e) {
                showNotification('Could not save to browser. Use download instead!');
                console.error('Save error:', e);
            }
        }
        
        function loadFromLocalStorage() {
            try {
                const savedData = localStorage.getItem(SAVE_KEY);
                if (!savedData) {
                    showNotification('No save found!');
                    return;
                }
                
                const saveData = JSON.parse(savedData);
                loadSaveData(saveData);
                showNotification('Game loaded successfully!');
                closeSaveLoad();
            } catch (e) {
                showNotification('Could not load from browser!');
                console.error('Load error:', e);
            }
        }
        
        function clearLocalStorage() {
            if (confirm('Are you sure you want to delete your browser save? This cannot be undone!')) {
                try {
                    localStorage.removeItem(SAVE_KEY);
                    showNotification('Browser save cleared!');
                    checkAutoSaveStatus();
                } catch (e) {
                    showNotification('Could not clear browser save!');
                }
            }
        }
        
        function downloadSave() {
            const saveData = prepareSaveData();
            const dataStr = JSON.stringify(saveData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `kinbound_save_${new Date().toISOString().slice(0, 10)}.kinbound`;
            link.click();
            
            showNotification('Save file downloaded!');
        }
        
        function uploadSave(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const saveData = JSON.parse(e.target.result);
                    loadSaveData(saveData);
                    showNotification('Save file loaded successfully!');
                    closeSaveLoad();
                } catch (error) {
                    showNotification('Invalid save file!');
                    console.error('Load error:', error);
                }
            };
            reader.readAsText(file);
            
            // Clear the input so the same file can be selected again
            event.target.value = '';
        }
        
        function generateSaveCode() {
            const saveData = prepareSaveData();
            const jsonStr = JSON.stringify(saveData);
            const compressed = btoa(jsonStr);
            document.getElementById('saveCodeArea').value = compressed;
            showNotification('Save code generated!');
        }
        
        function copySaveCode() {
            const textarea = document.getElementById('saveCodeArea');
            textarea.select();
            document.execCommand('copy');
            showNotification('Save code copied to clipboard!');
        }
        
        function loadSaveCode() {
            const code = document.getElementById('saveCodeArea').value.trim();
            if (!code) {
                showNotification('Please paste a save code first!');
                return;
            }
            
            try {
                const jsonStr = atob(code);
                const saveData = JSON.parse(jsonStr);
                loadSaveData(saveData);
                showNotification('Save code loaded successfully!');
                closeSaveLoad();
            } catch (e) {
                showNotification('Invalid save code!');
                console.error('Load error:', e);
            }
        }
        
        function loadSaveData(saveData) {
            // Validate save version
            if (saveData.version !== SAVE_VERSION) {
                if (!confirm('This save is from a different version. Loading may cause issues. Continue?')) {
                    return;
                }
            }
            
            // Load the game state
            const loadedState = saveData.gameState;
            
            // Convert Arrays back to Sets
            loadedState.kinDex = new Set(loadedState.kinDex);
            loadedState.radiantDex = new Set(loadedState.radiantDex);
            
            // Update game state
            Object.assign(gameState, loadedState);
            
            // Update all displays
            updateDisplay();
            updateTeamDisplay();
            updateBiomeTimers();
            
            // If we're on the main menu, stay there
            if (document.getElementById('biomeSelection').style.display !== 'none') {
                // Already on main menu
            } else {
                // Return to main menu
                leaveBiome();
            }
        }
        
        // Auto-save every 60 seconds
        setInterval(() => {
            if (gameState.totalKinCaught > 0) { // Only auto-save if game has started
                saveToLocalStorage();
            }
        }, 60000);
        
        // Save before closing/leaving page
        window.addEventListener('beforeunload', () => {
            if (gameState.totalKinCaught > 0) {
                saveToLocalStorage();
            }
        });
    </script>
</body>
</html>
                        